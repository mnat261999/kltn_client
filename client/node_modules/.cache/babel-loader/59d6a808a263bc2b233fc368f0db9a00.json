{"ast":null,"code":"let updateQueue = makeQueue();\n\nconst raf = fn => schedule(fn, updateQueue);\n\nlet writeQueue = makeQueue();\n\nraf.write = fn => schedule(fn, writeQueue);\n\nlet onStartQueue = makeQueue();\n\nraf.onStart = fn => schedule(fn, onStartQueue);\n\nlet onFrameQueue = makeQueue();\n\nraf.onFrame = fn => schedule(fn, onFrameQueue);\n\nlet onFinishQueue = makeQueue();\n\nraf.onFinish = fn => schedule(fn, onFinishQueue);\n\nlet timeouts = [];\n\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms;\n\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel);\n    if (~i) timeouts.splice(i, 1);\n    __raf.count -= ~i ? 1 : 0;\n  };\n\n  let timeout = {\n    time,\n    handler,\n    cancel\n  };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  __raf.count += 1;\n  start();\n  return timeout;\n};\n\nlet findTimeout = time => ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length);\n\nraf.cancel = fn => {\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\n\nraf.sync = fn => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\n\nraf.throttle = fn => {\n  let lastArgs;\n\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n\n  function throttled() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n\n  throttled.handler = fn;\n\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n\n  return throttled;\n};\n\nlet nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : () => {};\n\nraf.use = impl => nativeRaf = impl;\n\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\n\nraf.batchedUpdates = fn => fn();\n\nraf.catch = console.error;\nlet ts = -1;\nlet sync = false;\n\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    nativeRaf(loop);\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\n\nfunction update() {\n  let prevTs = ts;\n  ts = raf.now();\n  let count = findTimeout(ts);\n\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler());\n    __raf.count -= count;\n  }\n\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\n\nfunction makeQueue() {\n  let next = new Set();\n  let current = next;\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n\n    flush(arg) {\n      if (current.size) {\n        next = new Set();\n        __raf.count -= current.size;\n        eachSafely(current, fn => fn(arg) && next.add(fn));\n        __raf.count += next.size;\n        current = next;\n      }\n    }\n\n  };\n}\n\nfunction eachSafely(values, each) {\n  values.forEach(value => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\n\nconst __raf = {\n  count: 0,\n\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    __raf.count = 0;\n  }\n\n};\nexport { __raf, raf };","map":{"version":3,"mappings":"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","names":["updateQueue","makeQueue","fn","schedule","raf","write","writeQueue","onStart","onStartQueue","onFrame","onFrameQueue","onFinish","onFinishQueue","setTimeout","now","ms","timeouts","findIndex","t","cancel","i","splice","__raf","count","time","handler","findTimeout","timeout","start","length","delete","sync","batchedUpdates","throttle","lastArgs","args","queuedFn","throttled","window","requestAnimationFrame","use","impl","nativeRaf","performance","Date","catch","console","error","queue","add","ts","loop","update","eachSafely","flush","prevTs","Math","min","Set","next","current","has","size","arg","values","forEach","value","each","e","clear"],"sources":["D:\\Kltn\\test\\social-media\\node_modules\\rafz\\src\\raf.ts"],"sourcesContent":["import type {\n  FrameFn,\n  FrameUpdateFn,\n  NativeRaf,\n  Rafz,\n  Timeout,\n  Throttled,\n} from './types'\n\nexport { FrameFn, FrameUpdateFn, Timeout, Throttled }\n\nlet updateQueue = makeQueue<FrameUpdateFn>()\n\n/**\n * Schedule an update for next frame.\n * Your function can return `true` to repeat next frame.\n */\nexport const raf: Rafz = fn => schedule(fn, updateQueue)\n\nlet writeQueue = makeQueue<FrameFn>()\nraf.write = fn => schedule(fn, writeQueue)\n\nlet onStartQueue = makeQueue<FrameFn>()\nraf.onStart = fn => schedule(fn, onStartQueue)\n\nlet onFrameQueue = makeQueue<FrameFn>()\nraf.onFrame = fn => schedule(fn, onFrameQueue)\n\nlet onFinishQueue = makeQueue<FrameFn>()\nraf.onFinish = fn => schedule(fn, onFinishQueue)\n\nlet timeouts: Timeout[] = []\nraf.setTimeout = (handler, ms) => {\n  let time = raf.now() + ms\n  let cancel = () => {\n    let i = timeouts.findIndex(t => t.cancel == cancel)\n    if (~i) timeouts.splice(i, 1)\n    __raf.count -= ~i ? 1 : 0\n  }\n\n  let timeout: Timeout = { time, handler, cancel }\n  timeouts.splice(findTimeout(time), 0, timeout)\n  __raf.count += 1\n\n  start()\n  return timeout\n}\n\n/** Find the index where the given time is not greater. */\nlet findTimeout = (time: number) =>\n  ~(~timeouts.findIndex(t => t.time > time) || ~timeouts.length)\n\nraf.cancel = fn => {\n  updateQueue.delete(fn)\n  writeQueue.delete(fn)\n}\n\nraf.sync = fn => {\n  sync = true\n  raf.batchedUpdates(fn)\n  sync = false\n}\n\nraf.throttle = fn => {\n  let lastArgs: any\n  function queuedFn() {\n    try {\n      fn(...lastArgs)\n    } finally {\n      lastArgs = null\n    }\n  }\n  function throttled(...args: any) {\n    lastArgs = args\n    raf.onStart(queuedFn)\n  }\n  throttled.handler = fn\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn)\n    lastArgs = null\n  }\n  return throttled as any\n}\n\nlet nativeRaf =\n  typeof window != 'undefined'\n    ? (window.requestAnimationFrame as NativeRaf)\n    : () => {}\n\nraf.use = impl => (nativeRaf = impl)\nraf.now = typeof performance != 'undefined' ? () => performance.now() : Date.now\nraf.batchedUpdates = fn => fn()\nraf.catch = console.error\n\n/** The most recent timestamp. */\nlet ts = -1\n\n/** When true, scheduling is disabled. */\nlet sync = false\n\nfunction schedule<T extends Function>(fn: T, queue: Queue<T>) {\n  if (sync) {\n    queue.delete(fn)\n    fn(0)\n  } else {\n    queue.add(fn)\n    start()\n  }\n}\n\nfunction start() {\n  if (ts < 0) {\n    ts = 0\n    nativeRaf(loop)\n  }\n}\n\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop)\n    raf.batchedUpdates(update)\n  }\n}\n\nfunction update() {\n  let prevTs = ts\n  ts = raf.now()\n\n  // Flush timeouts whose time is up.\n  let count = findTimeout(ts)\n  if (count) {\n    eachSafely(timeouts.splice(0, count), t => t.handler())\n    __raf.count -= count\n  }\n\n  onStartQueue.flush()\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667)\n  onFrameQueue.flush()\n  writeQueue.flush()\n  onFinishQueue.flush()\n}\n\ninterface Queue<T extends Function = any> {\n  add: (fn: T) => void\n  delete: (fn: T) => boolean\n  flush: (arg?: any) => void\n}\n\nfunction makeQueue<T extends Function>(): Queue<T> {\n  let next = new Set<T>()\n  let current = next\n  return {\n    add(fn) {\n      __raf.count += current == next && !next.has(fn) ? 1 : 0\n      next.add(fn)\n    },\n    delete(fn) {\n      __raf.count -= current == next && next.has(fn) ? 1 : 0\n      return next.delete(fn)\n    },\n    flush(arg) {\n      if (current.size) {\n        next = new Set()\n        __raf.count -= current.size\n        eachSafely(current, fn => fn(arg) && next.add(fn))\n        __raf.count += next.size\n        current = next\n      }\n    },\n  }\n}\n\ninterface Eachable<T> {\n  forEach(cb: (value: T) => void): void\n}\n\nfunction eachSafely<T>(values: Eachable<T>, each: (value: T) => void) {\n  values.forEach(value => {\n    try {\n      each(value)\n    } catch (e) {\n      raf.catch(e)\n    }\n  })\n}\n\n/** Tree-shakable state for testing purposes */\nexport const __raf = {\n  /** The number of pending tasks */\n  count: 0,\n  /** Clear internal state. Never call from update loop! */\n  clear() {\n    ts = -1\n    timeouts = []\n    onStartQueue = makeQueue()\n    updateQueue = makeQueue()\n    onFrameQueue = makeQueue()\n    writeQueue = makeQueue()\n    onFinishQueue = makeQueue()\n    __raf.count = 0\n  },\n}\n"]},"metadata":{},"sourceType":"module"}