{"ast":null,"code":"import moment from 'moment';\nexport const generateData = (formdata, formName) => {\n  let dataToSubmit = {};\n\n  for (let key in formdata) {\n    if (key !== 'confirmPassword') {\n      if (key === 'dob') {\n        if (formdata[key].valueAsNumber) {\n          dataToSubmit[key] = formdata[key].valueAsNumber;\n        } else {\n          dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\");\n        }\n      } else {\n        dataToSubmit[key] = formdata[key].value;\n      }\n    }\n  }\n\n  return dataToSubmit;\n};\nexport const ifFormValid = (formdata, formName) => {\n  let formValid = true;\n\n  for (let key in formdata) {\n    console.log(formdata[key].valid);\n    formValid = formdata[key].valid && formValid;\n  }\n\n  console.log(\"ress\", formValid);\n  return formValid;\n}; //Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\n\nexport const validate = function (element) {\n  let formdata = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let error = [true, ''];\n\n  if (element.validation.confirm) {\n    const valid = element.value.trim() === formdata[element.validation.confirm].value;\n    const message = `${valid ? '' : 'Password do not match'}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex     \n\n\n  if (element.validation.email) {\n    const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\n    const message = `${!valid ? 'Must be a valid email' : ''}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không  \n\n\n  if (element.validation.required) {\n    const valid = element.value.trim() !== '';\n    const message = `${!valid ? 'this field is required' : ''}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  return error;\n};\nexport const update = (element, formdata, formName) => {\n  //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\n  //             Id(để xác định là field nào),\n  //             blur( luôn luôn bằng true) \n  //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị \n  const newFormdata = { ...formdata\n  }; //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào \n\n  const newElement = { ...newFormdata[element.id]\n  };\n  console.log(element.event); //Lấy value của field từ element.event.target.value\n\n  if (element.id === \"description\") {\n    console.log(element);\n\n    if (element.emojiInfo.emoji) {\n      newElement.value = newElement.value.toString().slice(0, element.emojiInfo.position) + element.event + newElement.value.toString().slice(element.emojiInfo.position);\n      console.log(newElement.value);\n    } else {\n      console.log(element.event);\n      newElement.value = element.event;\n    }\n  } else if (element.id === \"userTag\" || element.id === \"locationInput\") {\n    console.log(element.event);\n    newElement.value = element.event;\n  } else if (element.id === \"dob\") {\n    console.log(element.event.target.valueAsNumber);\n    newElement.value = element.event.target.value;\n    newElement.valueAsNumber = moment(element.event.target.valueAsNumber).format();\n  } else {\n    newElement.value = element.event.target.value;\n  }\n\n  if (element.blur) {\n    //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\n    let validData = validate(newElement, formdata); //Cập nhật lại valid và validationMessage trong newElement\n\n    newElement.valid = validData[0];\n    newElement.validationMessage = validData[1];\n  }\n\n  newElement.touched = element.blur; //Thêm newElement vào State newFormdata\n\n  newFormdata[element.id] = newElement;\n  console.log(newFormdata[element.id]);\n  return newFormdata;\n};\nexport const populateOptionFields = function (formData) {\n  let arrayData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let field = arguments.length > 2 ? arguments[2] : undefined;\n  const newArray = [];\n  const newFormData = { ...formData\n  };\n\n  switch (field) {\n    case 'description':\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    case 'userTag':\n      arrayData.forEach(item => {\n        newArray.push(item.userName);\n      });\n      break;\n\n    case 'locationInput':\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    default:\n      arrayData.forEach(item => {\n        newArray.push({\n          key: item._id,\n          value: item.name\n        });\n      });\n      break;\n  }\n\n  newFormData[field].config.options = newArray;\n  return newFormData;\n};\nexport const resetFields = (formData, formName) => {\n  const newFormData = { ...formData\n  };\n\n  for (let key in newFormData) {\n    if (key === 'images') {\n      newFormData[key].value = [];\n    } else {\n      newFormData[key].value = '';\n    }\n\n    newFormData[key].valid = '';\n    newFormData[key].touched = '';\n    newFormData[key].validationMessage = '';\n  }\n\n  return newFormData;\n};\nconst hashtagOrWordRegex = /#*\\w.*/g; // Gets the word that the user's caret is positioned on.\n\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\n  // First, backtrack until we find a character that can't\n  // be part of a word or hashtag.\n  if (content !== undefined) {\n    let index = caretIndex - 1;\n    let character = content[index]; //console.log(content);\n\n    let res = '';\n\n    do {\n      //console.log(index,content[index]);\n      let matches = content[index].match(hashtagOrWordRegex); // if this character is not part of a hashtag (e.g.\n      // it's a space or a period), return the word or\n      // hashtag in front of it.\n      //console.log(index,matches)\n\n      if (!matches || !matches.length) {\n        res = content.slice(index + 1, content.length);\n        break;\n      } // Otherwise, go to the previous character\n\n\n      index -= 1;\n    } while (index > 0);\n\n    return res;\n  }\n};\n\nconst nonEditingKeys = ['ArrowLeft', 'ArrowRight', 'Control', 'Shift'];\nexport const getActiveHashtag = (content, key, caretIndex) => {\n  if (nonEditingKeys.includes(key)) {\n    return null;\n  } // Figure out what word or hashtag the user is editing\n  // using the caret position and the content:\n\n\n  const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\n  console.log(activeWordOrHashtag); // if the word that the user is editing is a hashtag, return it.\n  // otherwise, return null.\n  //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\n};","map":{"version":3,"names":["moment","generateData","formdata","formName","dataToSubmit","key","valueAsNumber","value","format","ifFormValid","formValid","console","log","valid","validate","element","error","validation","confirm","trim","message","email","test","required","update","newFormdata","newElement","id","event","emojiInfo","emoji","toString","slice","position","target","blur","validData","validationMessage","touched","populateOptionFields","formData","arrayData","field","newArray","newFormData","forEach","item","push","name","userName","_id","config","options","resetFields","hashtagOrWordRegex","extractActiveWordOrHashtag","content","caretIndex","undefined","index","character","res","matches","match","length","nonEditingKeys","getActiveHashtag","includes","activeWordOrHashtag"],"sources":["D:/Kltn/test/social-media/client/src/components/ultils/Form/FormActions.js"],"sourcesContent":["import moment from 'moment';\r\n\r\nexport const generateData = (formdata, formName) =>{\r\n    \r\n    let dataToSubmit = {};\r\n    for (let key in formdata){\r\n        if(key !== 'confirmPassword')\r\n        {\r\n            if(key === 'dob'){\r\n                if(formdata[key].valueAsNumber){\r\n                dataToSubmit[key] = formdata[key].valueAsNumber; \r\n                }\r\n                else{\r\n                    dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\")\r\n                }\r\n            }else{\r\n                dataToSubmit[key] = formdata[key].value;\r\n            }\r\n        }\r\n    }\r\n    return dataToSubmit;\r\n}\r\n\r\nexport const ifFormValid = (formdata,formName) =>{\r\n    let formValid = true;\r\n\r\n    for (let key in formdata)\r\n    {\r\n        console.log(formdata[key].valid)\r\n        formValid = formdata[key].valid && formValid;\r\n    }\r\n\r\n    console.log(\"ress\", formValid)\r\n    return formValid;\r\n}\r\n\r\n//Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\r\nexport const validate = (element,formdata=[]) =>{\r\n    \r\n    let error = [true,''];\r\n\r\n    if (element.validation.confirm) {\r\n        const valid = element.value.trim() === formdata[element.validation.confirm].value;\r\n        const message = `${ valid ?'':'Password do not match'}`;\r\n        error = !valid ? [valid, message] : error;\r\n    }\r\n\r\n    // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex     \r\n    if (element.validation.email){\r\n        const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\r\n        const message = `${!valid ? 'Must be a valid email' : ''}`;\r\n        error = !valid ? [valid, message] : error;\r\n    }\r\n\r\n    // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không  \r\n    if(element.validation.required){\r\n        const valid = element.value.trim() !== '';\r\n        const message = `${!valid ? 'this field is required' : ''}`;\r\n        error = !valid ? [valid,message] : error;\r\n    }\r\n\r\n    return error;\r\n}\r\n\r\nexport const update = (element, formdata, formName) =>{\r\n\r\n    //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\r\n    //             Id(để xác định là field nào),\r\n    //             blur( luôn luôn bằng true) \r\n\r\n    //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị \r\n    const newFormdata = {...formdata};\r\n\r\n    //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào \r\n    const newElement = {\r\n        ...newFormdata[element.id]\r\n    }\r\n    \r\n    console.log(element.event);\r\n    //Lấy value của field từ element.event.target.value\r\n    if (element.id === \"description\"){\r\n        console.log(element);\r\n        if(element.emojiInfo.emoji){\r\n            newElement.value = newElement.value.toString().slice(0, element.emojiInfo.position) \r\n                                + element.event\r\n                                + newElement.value.toString().slice(element.emojiInfo.position)                                \r\n            console.log(newElement.value)\r\n        }else{\r\n            console.log(element.event)\r\n            newElement.value = element.event;\r\n        }\r\n    }else if (element.id === \"userTag\" || element.id === \"locationInput\"){\r\n        console.log(element.event)\r\n        newElement.value = element.event;\r\n    }else if(element.id === \"dob\"){\r\n        console.log(element.event.target.valueAsNumber)\r\n        newElement.value = element.event.target.value;\r\n        newElement.valueAsNumber = moment(element.event.target.valueAsNumber).format()\r\n    }else{\r\n        newElement.value = element.event.target.value;\r\n    }\r\n  \r\n    if(element.blur){\r\n        //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\r\n        let validData = validate(newElement,formdata);\r\n        //Cập nhật lại valid và validationMessage trong newElement\r\n        newElement.valid = validData[0];\r\n        newElement.validationMessage = validData[1];\r\n    }\r\n\r\n    newElement.touched = element.blur;\r\n    //Thêm newElement vào State newFormdata\r\n    newFormdata[element.id] = newElement;\r\n    console.log(newFormdata[element.id])\r\n    return newFormdata;\r\n};\r\n\r\nexport const populateOptionFields= (formData,arrayData = [], field) => {\r\n    const newArray = []\r\n    const newFormData = {...formData};\r\n\r\n    switch (field){\r\n        case ('description'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.name);\r\n            })\r\n            break;\r\n        case ('userTag'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.userName);\r\n            })\r\n            break;\r\n        case ('locationInput'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.name);\r\n            })\r\n            break;\r\n        default:\r\n            arrayData.forEach(item => {\r\n                newArray.push({ key: item._id, value: item.name });\r\n            })\r\n            break;\r\n    }\r\n    newFormData[field].config.options = newArray;\r\n    return newFormData;\r\n}\r\n\r\nexport const resetFields = (formData,formName) => {\r\n    const newFormData = {...formData};\r\n    for(let key in newFormData){\r\n        if(key==='images'){\r\n            newFormData[key].value = [];\r\n        }else{\r\n            newFormData[key].value = '';\r\n        }\r\n        newFormData[key].valid = '';\r\n        newFormData[key].touched = '';\r\n        newFormData[key].validationMessage = '';\r\n    }    \r\n    return newFormData;\r\n}\r\n\r\nconst hashtagOrWordRegex = /#*\\w.*/g;\r\n// Gets the word that the user's caret is positioned on.\r\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\r\n    // First, backtrack until we find a character that can't\r\n    // be part of a word or hashtag.\r\n    if(content !== undefined){\r\n    let index = caretIndex-1;\r\n    let character = content[index];\r\n    //console.log(content);\r\n    let res = '';\r\n    do {\r\n        //console.log(index,content[index]);\r\n        let matches = content[index].match(hashtagOrWordRegex);\r\n        // if this character is not part of a hashtag (e.g.\r\n        // it's a space or a period), return the word or\r\n        // hashtag in front of it.\r\n        //console.log(index,matches)\r\n        if (!matches || !matches.length) {\r\n            res = content.slice(index+1, content.length)\r\n            break;\r\n        }\r\n        // Otherwise, go to the previous character\r\n        index -= 1\r\n    } while (index > 0)\r\n    return res;\r\n    }\r\n}\r\n\r\nconst nonEditingKeys = [\r\n    'ArrowLeft',\r\n    'ArrowRight',\r\n    'Control',\r\n    'Shift',\r\n];\r\n\r\nexport const getActiveHashtag = (content, key, caretIndex) => {\r\n\r\n    if (nonEditingKeys.includes(key)) {\r\n        return null;\r\n    }\r\n\r\n    // Figure out what word or hashtag the user is editing\r\n    // using the caret position and the content:\r\n    const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\r\n    console.log(activeWordOrHashtag);\r\n    // if the word that the user is editing is a hashtag, return it.\r\n    // otherwise, return null.\r\n    //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}