{"ast":null,"code":"import React, { memo, useMemo } from 'react';\nimport { animated, useSpring, useTransition } from '@react-spring/web';\nimport { textPropsByEngine, useTheme, useMotionConfig, degreesToRadians } from '@nivo/core';\nimport { timeMillisecond, utcMillisecond, timeSecond, utcSecond, timeMinute, utcMinute, timeHour, utcHour, timeDay, utcDay, timeWeek, utcWeek, timeSunday, utcSunday, timeMonday, utcMonday, timeTuesday, utcTuesday, timeWednesday, utcWednesday, timeThursday, utcThursday, timeFriday, utcFriday, timeSaturday, utcSaturday, timeMonth, utcMonth, timeYear, utcYear } from 'd3-time';\nimport { timeFormat } from 'd3-time-format';\nimport { format } from 'd3-format';\nimport PropTypes from 'prop-types';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar centerScale = function centerScale(scale) {\n  var bandwidth = scale.bandwidth();\n  if (bandwidth === 0) return scale;\n  var offset = bandwidth / 2;\n\n  if (scale.round()) {\n    offset = Math.round(offset);\n  }\n\n  return function (d) {\n    var _scale;\n\n    return ((_scale = scale(d)) !== null && _scale !== void 0 ? _scale : 0) + offset;\n  };\n};\n\nvar timeByType = {\n  millisecond: [timeMillisecond, utcMillisecond],\n  second: [timeSecond, utcSecond],\n  minute: [timeMinute, utcMinute],\n  hour: [timeHour, utcHour],\n  day: [timeDay, utcDay],\n  week: [timeWeek, utcWeek],\n  sunday: [timeSunday, utcSunday],\n  monday: [timeMonday, utcMonday],\n  tuesday: [timeTuesday, utcTuesday],\n  wednesday: [timeWednesday, utcWednesday],\n  thursday: [timeThursday, utcThursday],\n  friday: [timeFriday, utcFriday],\n  saturday: [timeSaturday, utcSaturday],\n  month: [timeMonth, utcMonth],\n  year: [timeYear, utcYear]\n};\nvar timeTypes = Object.keys(timeByType);\nvar timeIntervalRegexp = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\".concat(timeTypes.join('|'), \")s?$\"), 'i');\n\nvar isInteger = function isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n};\n\nvar isArray = function isArray(value) {\n  return Array.isArray(value);\n};\n\nvar getScaleTicks = function getScaleTicks(scale, spec) {\n  if (Array.isArray(spec)) {\n    return spec;\n  }\n\n  if ('ticks' in scale) {\n    if (spec === undefined) {\n      return scale.ticks();\n    }\n\n    if (isInteger(spec)) {\n      return scale.ticks(spec);\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n      var matches = spec.match(timeIntervalRegexp);\n\n      if (matches) {\n        var timeType = timeByType[matches[2]][scale.useUTC ? 1 : 0];\n\n        if (matches[1] === undefined) {\n          return scale.ticks(timeType);\n        }\n\n        var interval = timeType.every(Number(matches[1]));\n\n        if (interval) {\n          return scale.ticks(interval);\n        }\n      }\n\n      throw new Error(\"Invalid tickValues: \".concat(spec));\n    }\n  }\n\n  return scale.domain();\n};\n\nvar computeCartesianTicks = function computeCartesianTicks(_ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      tickSize = _ref.tickSize,\n      tickPadding = _ref.tickPadding,\n      tickRotation = _ref.tickRotation,\n      _ref$engine = _ref.engine,\n      engine = _ref$engine === void 0 ? 'svg' : _ref$engine;\n  var values = getScaleTicks(scale, tickValues);\n  var textProps = textPropsByEngine[engine];\n  var position = 'bandwidth' in scale ? centerScale(scale) : scale;\n  var line = {\n    lineX: 0,\n    lineY: 0\n  };\n  var text = {\n    textX: 0,\n    textY: 0\n  };\n  var isRTL = typeof document === 'object' ? document.dir === 'rtl' : false;\n  var translate;\n  var textAlign = textProps.align.center;\n  var textBaseline = textProps.baseline.center;\n\n  if (axis === 'x') {\n    translate = function translate(d) {\n      var _position;\n\n      return {\n        x: (_position = position(d)) !== null && _position !== void 0 ? _position : 0,\n        y: 0\n      };\n    };\n\n    line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textBaseline = textProps.baseline.top;\n    } else {\n      textBaseline = textProps.baseline.bottom;\n    }\n\n    if (tickRotation === 0) {\n      textAlign = textProps.align.center;\n    } else if (ticksPosition === 'after' && tickRotation < 0 || ticksPosition === 'before' && tickRotation > 0) {\n      textAlign = textProps.align[isRTL ? 'left' : 'right'];\n      textBaseline = textProps.baseline.center;\n    } else if (ticksPosition === 'after' && tickRotation > 0 || ticksPosition === 'before' && tickRotation < 0) {\n      textAlign = textProps.align[isRTL ? 'right' : 'left'];\n      textBaseline = textProps.baseline.center;\n    }\n  } else {\n    translate = function translate(d) {\n      var _position2;\n\n      return {\n        x: 0,\n        y: (_position2 = position(d)) !== null && _position2 !== void 0 ? _position2 : 0\n      };\n    };\n\n    line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1);\n    text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1);\n\n    if (ticksPosition === 'after') {\n      textAlign = textProps.align.left;\n    } else {\n      textAlign = textProps.align.right;\n    }\n  }\n\n  var ticks = values.map(function (value) {\n    return _objectSpread2(_objectSpread2(_objectSpread2({\n      key: typeof value === 'number' || typeof value === 'string' ? value : \"\".concat(value),\n      value: value\n    }, translate(value)), line), text);\n  });\n  return {\n    ticks: ticks,\n    textAlign: textAlign,\n    textBaseline: textBaseline\n  };\n};\n\nvar getFormatter = function getFormatter(format$1, scale) {\n  if (typeof format$1 === 'undefined' || typeof format$1 === 'function') return format$1;\n\n  if (scale.type === 'time') {\n    var formatter = timeFormat(format$1);\n    return function (d) {\n      return formatter(d instanceof Date ? d : new Date(d));\n    };\n  }\n\n  return format(format$1);\n};\n\nvar computeGridLines = function computeGridLines(_ref2) {\n  var width = _ref2.width,\n      height = _ref2.height,\n      scale = _ref2.scale,\n      axis = _ref2.axis,\n      _values = _ref2.values;\n  var lineValues = isArray(_values) ? _values : undefined;\n  var lineCount = isInteger(_values) ? _values : undefined;\n  var values = lineValues || getScaleTicks(scale, lineCount);\n  var position = 'bandwidth' in scale ? centerScale(scale) : scale;\n  var lines = axis === 'x' ? values.map(function (value) {\n    var _position3, _position4;\n\n    return {\n      key: \"\".concat(value),\n      x1: (_position3 = position(value)) !== null && _position3 !== void 0 ? _position3 : 0,\n      x2: (_position4 = position(value)) !== null && _position4 !== void 0 ? _position4 : 0,\n      y1: 0,\n      y2: height\n    };\n  }) : values.map(function (value) {\n    var _position5, _position6;\n\n    return {\n      key: \"\".concat(value),\n      x1: 0,\n      x2: width,\n      y1: (_position5 = position(value)) !== null && _position5 !== void 0 ? _position5 : 0,\n      y2: (_position6 = position(value)) !== null && _position6 !== void 0 ? _position6 : 0\n    };\n  });\n  return lines;\n};\n\nvar AxisTick = function AxisTick(_ref) {\n  var _format;\n\n  var _value = _ref.value,\n      format = _ref.format,\n      lineX = _ref.lineX,\n      lineY = _ref.lineY,\n      _onClick = _ref.onClick,\n      textBaseline = _ref.textBaseline,\n      textAnchor = _ref.textAnchor,\n      animatedProps = _ref.animatedProps;\n  var theme = useTheme();\n  var value = (_format = format === null || format === void 0 ? void 0 : format(_value)) !== null && _format !== void 0 ? _format : _value;\n  var props = useMemo(function () {\n    var style = {\n      opacity: animatedProps.opacity\n    };\n\n    if (!_onClick) {\n      return {\n        style: style\n      };\n    }\n\n    return {\n      style: _objectSpread2(_objectSpread2({}, style), {}, {\n        cursor: 'pointer'\n      }),\n      onClick: function onClick(event) {\n        return _onClick(event, value);\n      }\n    };\n  }, [animatedProps.opacity, _onClick, value]);\n  return React.createElement(animated.g, Object.assign({\n    transform: animatedProps.transform\n  }, props), React.createElement(\"line\", {\n    x1: 0,\n    x2: lineX,\n    y1: 0,\n    y2: lineY,\n    style: theme.axis.ticks.line\n  }), React.createElement(animated.text, {\n    dominantBaseline: textBaseline,\n    textAnchor: textAnchor,\n    transform: animatedProps.textTransform,\n    style: theme.axis.ticks.text\n  }, value));\n};\n\nvar memoizedAxisTick = memo(AxisTick);\n\nvar Axis = function Axis(_ref) {\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      length = _ref.length,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      _ref$tickSize = _ref.tickSize,\n      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,\n      _ref$tickPadding = _ref.tickPadding,\n      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,\n      _ref$tickRotation = _ref.tickRotation,\n      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,\n      format = _ref.format,\n      _ref$renderTick = _ref.renderTick,\n      renderTick = _ref$renderTick === void 0 ? memoizedAxisTick : _ref$renderTick,\n      legend = _ref.legend,\n      _ref$legendPosition = _ref.legendPosition,\n      legendPosition = _ref$legendPosition === void 0 ? 'end' : _ref$legendPosition,\n      _ref$legendOffset = _ref.legendOffset,\n      legendOffset = _ref$legendOffset === void 0 ? 0 : _ref$legendOffset,\n      onClick = _ref.onClick,\n      ariaHidden = _ref.ariaHidden;\n  var theme = useTheme();\n  var formatValue = useMemo(function () {\n    return getFormatter(format, scale);\n  }, [format, scale]);\n\n  var _computeCartesianTick = computeCartesianTicks({\n    axis: axis,\n    scale: scale,\n    ticksPosition: ticksPosition,\n    tickValues: tickValues,\n    tickSize: tickSize,\n    tickPadding: tickPadding,\n    tickRotation: tickRotation\n  }),\n      ticks = _computeCartesianTick.ticks,\n      textAlign = _computeCartesianTick.textAlign,\n      textBaseline = _computeCartesianTick.textBaseline;\n\n  var legendNode = null;\n\n  if (legend !== undefined) {\n    var legendX = 0;\n    var legendY = 0;\n    var legendRotation = 0;\n    var textAnchor;\n\n    if (axis === 'y') {\n      legendRotation = -90;\n      legendX = legendOffset;\n\n      if (legendPosition === 'start') {\n        textAnchor = 'start';\n        legendY = length;\n      } else if (legendPosition === 'middle') {\n        textAnchor = 'middle';\n        legendY = length / 2;\n      } else if (legendPosition === 'end') {\n        textAnchor = 'end';\n      }\n    } else {\n      legendY = legendOffset;\n\n      if (legendPosition === 'start') {\n        textAnchor = 'start';\n      } else if (legendPosition === 'middle') {\n        textAnchor = 'middle';\n        legendX = length / 2;\n      } else if (legendPosition === 'end') {\n        textAnchor = 'end';\n        legendX = length;\n      }\n    }\n\n    legendNode = React.createElement(\"text\", {\n      transform: \"translate(\".concat(legendX, \", \").concat(legendY, \") rotate(\").concat(legendRotation, \")\"),\n      textAnchor: textAnchor,\n      style: _objectSpread2({\n        dominantBaseline: 'central'\n      }, theme.axis.legend.text)\n    }, legend);\n  }\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var animatedProps = useSpring({\n    transform: \"translate(\".concat(x, \",\").concat(y, \")\"),\n    lineX2: axis === 'x' ? length : 0,\n    lineY2: axis === 'x' ? 0 : length,\n    config: springConfig,\n    immediate: !animate\n  });\n  var transition = useTransition(ticks, {\n    keys: function keys(tick) {\n      return tick.key;\n    },\n    initial: function initial(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    from: function from(tick) {\n      return {\n        opacity: 0,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    enter: function enter(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    update: function update(tick) {\n      return {\n        opacity: 1,\n        transform: \"translate(\".concat(tick.x, \",\").concat(tick.y, \")\"),\n        textTransform: \"translate(\".concat(tick.textX, \",\").concat(tick.textY, \") rotate(\").concat(tickRotation, \")\")\n      };\n    },\n    leave: {\n      opacity: 0\n    },\n    config: springConfig,\n    immediate: !animate\n  });\n  return React.createElement(animated.g, {\n    transform: animatedProps.transform,\n    \"aria-hidden\": ariaHidden\n  }, transition(function (transitionProps, tick, _state, tickIndex) {\n    return React.createElement(renderTick, _objectSpread2(_objectSpread2({\n      tickIndex: tickIndex,\n      format: formatValue,\n      rotate: tickRotation,\n      textBaseline: textBaseline,\n      textAnchor: textAlign,\n      animatedProps: transitionProps\n    }, tick), onClick ? {\n      onClick: onClick\n    } : {}));\n  }), React.createElement(animated.line, {\n    style: theme.axis.domain.line,\n    x1: 0,\n    x2: animatedProps.lineX2,\n    y1: 0,\n    y2: animatedProps.lineY2\n  }), legendNode);\n};\n\nvar memoizedAxis = memo(Axis);\nvar axisPropTypes = {\n  ticksPosition: PropTypes.oneOf(['before', 'after']),\n  tickValues: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])), PropTypes.string]),\n  tickSize: PropTypes.number,\n  tickPadding: PropTypes.number,\n  tickRotation: PropTypes.number,\n  format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n  renderTick: PropTypes.func,\n  legend: PropTypes.node,\n  legendPosition: PropTypes.oneOf(['start', 'middle', 'end']),\n  legendOffset: PropTypes.number,\n  ariaHidden: PropTypes.bool\n};\nvar axisPropType = PropTypes.shape(axisPropTypes);\nvar positions = ['top', 'right', 'bottom', 'left'];\nvar Axes = memo(function (_ref) {\n  var xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      width = _ref.width,\n      height = _ref.height,\n      top = _ref.top,\n      right = _ref.right,\n      bottom = _ref.bottom,\n      left = _ref.left;\n  var axes = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  return React.createElement(React.Fragment, null, positions.map(function (position) {\n    var axis = axes[position];\n    if (!axis) return null;\n    var isXAxis = position === 'top' || position === 'bottom';\n    var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n    return React.createElement(memoizedAxis, Object.assign({\n      key: position\n    }, axis, {\n      axis: isXAxis ? 'x' : 'y',\n      x: position === 'right' ? width : 0,\n      y: position === 'bottom' ? height : 0,\n      scale: isXAxis ? xScale : yScale,\n      length: isXAxis ? width : height,\n      ticksPosition: ticksPosition\n    }));\n  }));\n});\nvar GridLine = memo(function (_ref) {\n  var animatedProps = _ref.animatedProps;\n  var theme = useTheme();\n  return React.createElement(animated.line, Object.assign({}, animatedProps, theme.grid.line));\n});\nvar GridLines = memo(function (_ref) {\n  var lines = _ref.lines;\n\n  var _useMotionConfig = useMotionConfig(),\n      animate = _useMotionConfig.animate,\n      springConfig = _useMotionConfig.config;\n\n  var transition = useTransition(lines, {\n    keys: function keys(line) {\n      return line.key;\n    },\n    initial: function initial(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    from: function from(line) {\n      return {\n        opacity: 0,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    enter: function enter(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    update: function update(line) {\n      return {\n        opacity: 1,\n        x1: line.x1,\n        x2: line.x2,\n        y1: line.y1,\n        y2: line.y2\n      };\n    },\n    leave: {\n      opacity: 0\n    },\n    config: springConfig,\n    immediate: !animate\n  });\n  return React.createElement(\"g\", null, transition(function (animatedProps, line) {\n    return React.createElement(GridLine, Object.assign({}, line, {\n      key: line.key,\n      animatedProps: animatedProps\n    }));\n  }));\n});\nvar Grid = memo(function (_ref) {\n  var width = _ref.width,\n      height = _ref.height,\n      xScale = _ref.xScale,\n      yScale = _ref.yScale,\n      xValues = _ref.xValues,\n      yValues = _ref.yValues;\n  var xLines = useMemo(function () {\n    if (!xScale) return false;\n    return computeGridLines({\n      width: width,\n      height: height,\n      scale: xScale,\n      axis: 'x',\n      values: xValues\n    });\n  }, [xScale, xValues, width, height]);\n  var yLines = useMemo(function () {\n    if (!yScale) return false;\n    return computeGridLines({\n      width: width,\n      height: height,\n      scale: yScale,\n      axis: 'y',\n      values: yValues\n    });\n  }, [height, width, yScale, yValues]);\n  return React.createElement(React.Fragment, null, xLines && React.createElement(GridLines, {\n    lines: xLines\n  }), yLines && React.createElement(GridLines, {\n    lines: yLines\n  }));\n});\n\nvar renderAxisToCanvas = function renderAxisToCanvas(ctx, _ref) {\n  var _theme$axis$domain$li;\n\n  var axis = _ref.axis,\n      scale = _ref.scale,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      length = _ref.length,\n      ticksPosition = _ref.ticksPosition,\n      tickValues = _ref.tickValues,\n      _ref$tickSize = _ref.tickSize,\n      tickSize = _ref$tickSize === void 0 ? 5 : _ref$tickSize,\n      _ref$tickPadding = _ref.tickPadding,\n      tickPadding = _ref$tickPadding === void 0 ? 5 : _ref$tickPadding,\n      _ref$tickRotation = _ref.tickRotation,\n      tickRotation = _ref$tickRotation === void 0 ? 0 : _ref$tickRotation,\n      _format = _ref.format,\n      legend = _ref.legend,\n      _ref$legendPosition = _ref.legendPosition,\n      legendPosition = _ref$legendPosition === void 0 ? 'end' : _ref$legendPosition,\n      _ref$legendOffset = _ref.legendOffset,\n      legendOffset = _ref$legendOffset === void 0 ? 0 : _ref$legendOffset,\n      theme = _ref.theme;\n\n  var _computeCartesianTick = computeCartesianTicks({\n    axis: axis,\n    scale: scale,\n    ticksPosition: ticksPosition,\n    tickValues: tickValues,\n    tickSize: tickSize,\n    tickPadding: tickPadding,\n    tickRotation: tickRotation,\n    engine: 'canvas'\n  }),\n      ticks = _computeCartesianTick.ticks,\n      textAlign = _computeCartesianTick.textAlign,\n      textBaseline = _computeCartesianTick.textBaseline;\n\n  ctx.save();\n  ctx.translate(x, y);\n  ctx.textAlign = textAlign;\n  ctx.textBaseline = textBaseline;\n  ctx.font = \"\".concat(theme.axis.ticks.text.fontSize, \"px \").concat(theme.axis.ticks.text.fontFamily);\n\n  if (((_theme$axis$domain$li = theme.axis.domain.line.strokeWidth) !== null && _theme$axis$domain$li !== void 0 ? _theme$axis$domain$li : 0) > 0) {\n    ctx.lineWidth = Number(theme.axis.domain.line.strokeWidth);\n    ctx.lineCap = 'square';\n\n    if (theme.axis.domain.line.stroke) {\n      ctx.strokeStyle = theme.axis.domain.line.stroke;\n    }\n\n    ctx.beginPath();\n    ctx.moveTo(0, 0);\n    ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length);\n    ctx.stroke();\n  }\n\n  var format = typeof _format === 'function' ? _format : function (value) {\n    return \"\".concat(value);\n  };\n  ticks.forEach(function (tick) {\n    var _theme$axis$ticks$lin;\n\n    if (((_theme$axis$ticks$lin = theme.axis.ticks.line.strokeWidth) !== null && _theme$axis$ticks$lin !== void 0 ? _theme$axis$ticks$lin : 0) > 0) {\n      ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth);\n      ctx.lineCap = 'square';\n\n      if (theme.axis.ticks.line.stroke) {\n        ctx.strokeStyle = theme.axis.ticks.line.stroke;\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(tick.x, tick.y);\n      ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY);\n      ctx.stroke();\n    }\n\n    var value = format(tick.value);\n    ctx.save();\n    ctx.translate(tick.x + tick.textX, tick.y + tick.textY);\n    ctx.rotate(degreesToRadians(tickRotation));\n\n    if (theme.axis.ticks.text.fill) {\n      ctx.fillStyle = theme.axis.ticks.text.fill;\n    }\n\n    ctx.fillText(String(value), 0, 0);\n    ctx.restore();\n  });\n\n  if (legend !== undefined) {\n    var legendX = 0;\n    var legendY = 0;\n    var legendRotation = 0;\n    var _textAlign = 'center';\n\n    if (axis === 'y') {\n      legendRotation = -90;\n      legendX = legendOffset;\n\n      if (legendPosition === 'start') {\n        _textAlign = 'start';\n        legendY = length;\n      } else if (legendPosition === 'middle') {\n        _textAlign = 'center';\n        legendY = length / 2;\n      } else if (legendPosition === 'end') {\n        _textAlign = 'end';\n      }\n    } else {\n      legendY = legendOffset;\n\n      if (legendPosition === 'start') {\n        _textAlign = 'start';\n      } else if (legendPosition === 'middle') {\n        _textAlign = 'center';\n        legendX = length / 2;\n      } else if (legendPosition === 'end') {\n        _textAlign = 'end';\n        legendX = length;\n      }\n    }\n\n    ctx.translate(legendX, legendY);\n    ctx.rotate(degreesToRadians(legendRotation));\n    ctx.font = \"\".concat(theme.axis.legend.text.fontWeight ? \"\".concat(theme.axis.legend.text.fontWeight, \" \") : '').concat(theme.axis.legend.text.fontSize, \"px \").concat(theme.axis.legend.text.fontFamily);\n\n    if (theme.axis.legend.text.fill) {\n      ctx.fillStyle = theme.axis.legend.text.fill;\n    }\n\n    ctx.textAlign = _textAlign;\n    ctx.textBaseline = 'middle';\n    ctx.fillText(legend, 0, 0);\n  }\n\n  ctx.restore();\n};\n\nvar renderAxesToCanvas = function renderAxesToCanvas(ctx, _ref2) {\n  var xScale = _ref2.xScale,\n      yScale = _ref2.yScale,\n      width = _ref2.width,\n      height = _ref2.height,\n      top = _ref2.top,\n      right = _ref2.right,\n      bottom = _ref2.bottom,\n      left = _ref2.left,\n      theme = _ref2.theme;\n  var axes = {\n    top: top,\n    right: right,\n    bottom: bottom,\n    left: left\n  };\n  positions.forEach(function (position) {\n    var axis = axes[position];\n    if (!axis) return null;\n    var isXAxis = position === 'top' || position === 'bottom';\n    var ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after';\n    var scale = isXAxis ? xScale : yScale;\n    var format = getFormatter(axis.format, scale);\n    renderAxisToCanvas(ctx, _objectSpread2(_objectSpread2({}, axis), {}, {\n      axis: isXAxis ? 'x' : 'y',\n      x: position === 'right' ? width : 0,\n      y: position === 'bottom' ? height : 0,\n      scale: scale,\n      format: format,\n      length: isXAxis ? width : height,\n      ticksPosition: ticksPosition,\n      theme: theme\n    }));\n  });\n};\n\nvar renderGridLinesToCanvas = function renderGridLinesToCanvas(ctx, _ref3) {\n  var width = _ref3.width,\n      height = _ref3.height,\n      scale = _ref3.scale,\n      axis = _ref3.axis,\n      values = _ref3.values;\n  var lines = computeGridLines({\n    width: width,\n    height: height,\n    scale: scale,\n    axis: axis,\n    values: values\n  });\n  lines.forEach(function (line) {\n    ctx.beginPath();\n    ctx.moveTo(line.x1, line.y1);\n    ctx.lineTo(line.x2, line.y2);\n    ctx.stroke();\n  });\n};\n\nexport { Axes, memoizedAxis as Axis, memoizedAxisTick as AxisTick, Grid, GridLine, GridLines, axisPropType, axisPropTypes, positions, renderAxesToCanvas, renderAxisToCanvas, renderGridLinesToCanvas };","map":{"version":3,"mappings":";;;;;;;;AAAe,SAASA,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;EACvD,IAAID,GAAG,IAAID,GAAX,EAAgB;IACdG,MAAM,CAACC,cAAP,CAAsBJ,GAAtB,EAA2BC,GAA3B,EAAgC;MAC9BC,KAAK,EAAEA,KADuB;MAE9BG,UAAU,EAAE,IAFkB;MAG9BC,YAAY,EAAE,IAHgB;MAI9BC,QAAQ,EAAE;IAJoB,CAAhC;EAMD,CAPD,MAOO;IACLP,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;EACD;;EAED,OAAOF,GAAP;AACF;;ACXA,SAASQ,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;EACvC,IAAIC,IAAI,GAAGR,MAAM,CAACQ,IAAP,CAAYF,MAAZ,CAAX;;EAEA,IAAIN,MAAM,CAACS,qBAAX,EAAkC;IAChC,IAAIC,OAAO,GAAGV,MAAM,CAACS,qBAAP,CAA6BH,MAA7B,CAAd;IACA,IAAIC,cAAJ,EAAoBG,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;MAC1D,OAAOZ,MAAM,CAACa,wBAAP,CAAgCP,MAAhC,EAAwCM,GAAxC,EAA6CV,UAApD;IACD,CAF6B,CAAV;IAGpBM,IAAI,CAACM,IAAL,CAAUC,KAAV,CAAgBP,IAAhB,EAAsBE,OAAtB;EACD;;EAED,OAAOF,IAAP;AACD;;AAEc,SAASQ,cAAT,CAAwBC,MAAxB,EAAgC;EAC7C,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;IACzC,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;IAEA,IAAIA,CAAC,GAAG,CAAR,EAAW;MACTb,OAAO,CAACL,MAAM,CAACqB,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUxB,GAAV,EAAe;QACnDG,eAAc,CAACgB,MAAD,EAASnB,GAAT,EAAcuB,MAAM,CAACvB,GAAD,CAApB,CAAdG;MACD,CAFD;IAGD,CAJD,MAIO,IAAID,MAAM,CAACuB,yBAAX,EAAsC;MAC3CvB,MAAM,CAACwB,gBAAP,CAAwBP,MAAxB,EAAgCjB,MAAM,CAACuB,yBAAP,CAAiCF,MAAjC,CAAhC;IACD,CAFM,MAEA;MACLhB,OAAO,CAACL,MAAM,CAACqB,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUxB,GAAV,EAAe;QAC7CE,MAAM,CAACC,cAAP,CAAsBgB,MAAtB,EAA8BnB,GAA9B,EAAmCE,MAAM,CAACa,wBAAP,CAAgCQ,MAAhC,EAAwCvB,GAAxC,CAAnC;MACD,CAFD;IAGD;EACF;;EAED,OAAOmB,MAAP;AACF;;ACaO,IAAMQ,WAAW,GAAG,SAAdA,WAAc,CAAQC,KAAR,EAAsC;EAC7D,IAAMC,SAAS,GAAGD,KAAK,CAACC,SAAND,EAAlB;EAEA,IAAIC,SAAS,KAAK,CAAlB,EAAqB,OAAOD,KAAP;EAErB,IAAIE,MAAM,GAAGD,SAAS,GAAG,CAAzB;;EACA,IAAID,KAAK,CAACG,KAANH,EAAJ,EAAmB;IACfE,MAAM,GAAGE,IAAI,CAACD,KAALC,CAAWF,MAAXE,CAATF;EACH;;EAED,OAAO,UAAkBG,CAAlB;IAAA;;IAAA,OAA2B,WAACL,KAAK,CAACK,CAAD,CAAN,2CAAa,CAAb,IAAkBH,MAA7C;EAAP;AAVG;;AAaP,IAAMI,UAA0E,GAAG;EAC/EC,WAAW,EAAE,CAACC,eAAD,EAAkBC,cAAlB,CADkE;EAE/EC,MAAM,EAAE,CAACC,UAAD,EAAaC,SAAb,CAFuE;EAG/EC,MAAM,EAAE,CAACC,UAAD,EAAaC,SAAb,CAHuE;EAI/EC,IAAI,EAAE,CAACC,QAAD,EAAWC,OAAX,CAJyE;EAK/EC,GAAG,EAAE,CAACC,OAAD,EAAUC,MAAV,CAL0E;EAM/EC,IAAI,EAAE,CAACC,QAAD,EAAWC,OAAX,CANyE;EAO/EC,MAAM,EAAE,CAACC,UAAD,EAAaC,SAAb,CAPuE;EAQ/EC,MAAM,EAAE,CAACC,UAAD,EAAaC,SAAb,CARuE;EAS/EC,OAAO,EAAE,CAACC,WAAD,EAAcC,UAAd,CATsE;EAU/EC,SAAS,EAAE,CAACC,aAAD,EAAgBC,YAAhB,CAVoE;EAW/EC,QAAQ,EAAE,CAACC,YAAD,EAAeC,WAAf,CAXqE;EAY/EC,MAAM,EAAE,CAACC,UAAD,EAAaC,SAAb,CAZuE;EAa/EC,QAAQ,EAAE,CAACC,YAAD,EAAeC,WAAf,CAbqE;EAc/EC,KAAK,EAAE,CAACC,SAAD,EAAYC,QAAZ,CAdwE;EAe/EC,IAAI,EAAE,CAACC,QAAD,EAAWC,OAAX;AAfyE,CAAnF;AAkBA,IAAMC,SAAS,GAAG9E,MAAM,CAACQ,IAAPR,CAAYgC,UAAZhC,CAAlB;AACA,IAAM+E,kBAAkB,GAAG,IAAIC,MAAJ,iCAAoCF,SAAS,CAACG,IAAVH,CAAe,GAAfA,CAApC,WAA+D,GAA/D,CAA3B;;AAEA,IAAMI,SAAS,GAAG,SAAZA,SAAY,CAACnF,KAAD;EAAA,OACd,OAAOA,KAAP,KAAiB,QAAjB,IAA6BoF,QAAQ,CAACpF,KAAD,CAArC,IAAgD+B,IAAI,CAACsD,KAALtD,CAAW/B,KAAX+B,MAAsB/B,KADxD;AAAlB;;AAGA,IAAMsF,OAAO,GAAG,SAAVA,OAAU,CAAItF,KAAJ;EAAA,OAAqCuF,KAAK,CAACD,OAANC,CAAcvF,KAAduF,CAArC;AAAhB;;AAEO,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CACzB7D,KADyB,EAEzB8D,IAFyB,EAGxB;EAED,IAAIF,KAAK,CAACD,OAANC,CAAcE,IAAdF,CAAJ,EAAyB;IACrB,OAAOE,IAAP;EACH;;EAGD,IAAI,WAAW9D,KAAf,EAAsB;IAElB,IAAI8D,IAAI,KAAKC,SAAb,EAAwB;MACpB,OAAO/D,KAAK,CAACgE,KAANhE,EAAP;IACH;;IAGD,IAAIwD,SAAS,CAACM,IAAD,CAAb,EAAqB;MACjB,OAAO9D,KAAK,CAACgE,KAANhE,CAAY8D,IAAZ9D,CAAP;IACH;;IAED,IAAI,OAAO8D,IAAP,KAAgB,QAAhB,IAA4B,YAAY9D,KAA5C,EAAmD;MAE/C,IAAMiE,OAAO,GAAGH,IAAI,CAACI,KAALJ,CAAWT,kBAAXS,CAAhB;;MACA,IAAIG,OAAJ,EAAa;QAIT,IAAME,QAAQ,GAAG7D,UAAU,CAAC2D,OAAO,CAAC,CAAD,CAAR,CAAV3D,CAAuBN,KAAK,CAACoE,MAANpE,GAAe,CAAfA,GAAmB,CAA1CM,CAAjB;;QAEA,IAAI2D,OAAO,CAAC,CAAD,CAAPA,KAAeF,SAAnB,EAA8B;UAC1B,OAAO/D,KAAK,CAACgE,KAANhE,CAAYmE,QAAZnE,CAAP;QACH;;QAED,IAAMqE,QAAQ,GAAGF,QAAQ,CAACG,KAATH,CAAeI,MAAM,CAACN,OAAO,CAAC,CAAD,CAAR,CAArBE,CAAjB;;QAEA,IAAIE,QAAJ,EAAc;UACV,OAAOrE,KAAK,CAACgE,KAANhE,CAAYqE,QAAZrE,CAAP;QACH;MACJ;;MAED,MAAM,IAAIwE,KAAJ,+BAAiCV,IAAjC,EAAN;IACH;EACJ;;EAGD,OAAO9D,KAAK,CAACyE,MAANzE,EAAP;AA9CG;;AAiDA,IAAM0E,qBAAqB,GAAG,SAAxBA,qBAAwB,OAkB/B;EAAA,IAjBFC,IAiBE,QAjBFA,IAiBE;EAAA,IAhBF3E,KAgBE,QAhBFA,KAgBE;EAAA,IAfF4E,aAeE,QAfFA,aAeE;EAAA,IAdFC,UAcE,QAdFA,UAcE;EAAA,IAbFC,QAaE,QAbFA,QAaE;EAAA,IAZFC,WAYE,QAZFA,WAYE;EAAA,IAXFC,YAWE,QAXFA,YAWE;EAAA,uBAVFC,MAUE;EAAA,IAVFA,MAUE,4BAVO,KAUP;EACF,IAAMC,MAAM,GAAGrB,aAAa,CAAC7D,KAAD,EAAQ6E,UAAR,CAA5B;EAEA,IAAMM,SAAS,GAAGC,iBAAiB,CAACH,MAAD,CAAnC;EAEA,IAAMI,QAAQ,GAAG,eAAerF,KAAf,GAAuBD,WAAW,CAACC,KAAD,CAAlC,GAA4CA,KAA7D;EACA,IAAMsF,IAAI,GAAG;IAAEC,KAAK,EAAE,CAAT;IAAYC,KAAK,EAAE;EAAnB,CAAb;EACA,IAAMC,IAAI,GAAG;IAAEC,KAAK,EAAE,CAAT;IAAYC,KAAK,EAAE;EAAnB,CAAb;EAEA,IAAMC,KAAK,GAAG,OAAOC,QAAP,KAAoB,QAApB,GAA+BA,QAAQ,CAACC,GAATD,KAAiB,KAAhD,GAAwD,KAAtE;EACA,IAAIE,SAAJ;EACA,IAAIC,SAA0B,GAAGb,SAAS,CAACc,KAAVd,CAAgBe,MAAjD;EACA,IAAIC,YAAgC,GAAGhB,SAAS,CAACiB,QAAVjB,CAAmBe,MAA1D;;EAEA,IAAIvB,IAAI,KAAK,GAAb,EAAkB;IACdoB,SAAS,GAAG,sBAAC;MAAA;;MAAA,OAAK;QAAEM,CAAC,eAAEhB,QAAQ,CAAChF,CAAD,CAAV,iDAAiB,CAApB;QAAuBiG,CAAC,EAAE;MAA1B,CAAL;IAAb;;IAEAhB,IAAI,CAACE,KAALF,GAAaR,QAAQ,IAAIF,aAAa,KAAK,OAAlBA,GAA4B,CAA5BA,GAAgC,CAAC,CAArC,CAArBU;IACAG,IAAI,CAACE,KAALF,GAAa,CAACX,QAAQ,GAAGC,WAAZ,KAA4BH,aAAa,KAAK,OAAlBA,GAA4B,CAA5BA,GAAgC,CAAC,CAA7D,CAAba;;IAEA,IAAIb,aAAa,KAAK,OAAtB,EAA+B;MAC3BuB,YAAY,GAAGhB,SAAS,CAACiB,QAAVjB,CAAmBoB,GAAlCJ;IADJ,OAEO;MACHA,YAAY,GAAGhB,SAAS,CAACiB,QAAVjB,CAAmBqB,MAAlCL;IACH;;IAED,IAAInB,YAAY,KAAK,CAArB,EAAwB;MACpBgB,SAAS,GAAGb,SAAS,CAACc,KAAVd,CAAgBe,MAA5BF;IADJ,OAEO,IACFpB,aAAa,KAAK,OAAlBA,IAA6BI,YAAY,GAAG,CAA5CJ,IACAA,aAAa,KAAK,QAAlBA,IAA8BI,YAAY,GAAG,CAF3C,EAGL;MACEgB,SAAS,GAAGb,SAAS,CAACc,KAAVd,CAAgBS,KAAK,GAAG,MAAH,GAAY,OAAjCT,CAAZa;MACAG,YAAY,GAAGhB,SAAS,CAACiB,QAAVjB,CAAmBe,MAAlCC;IALG,OAMA,IACFvB,aAAa,KAAK,OAAlBA,IAA6BI,YAAY,GAAG,CAA5CJ,IACAA,aAAa,KAAK,QAAlBA,IAA8BI,YAAY,GAAG,CAF3C,EAGL;MACEgB,SAAS,GAAGb,SAAS,CAACc,KAAVd,CAAgBS,KAAK,GAAG,OAAH,GAAa,MAAlCT,CAAZa;MACAG,YAAY,GAAGhB,SAAS,CAACiB,QAAVjB,CAAmBe,MAAlCC;IACH;EA1BL,OA2BO;IACHJ,SAAS,GAAG,sBAAC;MAAA;;MAAA,OAAK;QAAEM,CAAC,EAAE,CAAL;QAAQC,CAAC,gBAAEjB,QAAQ,CAAChF,CAAD,CAAV,mDAAiB;MAA1B,CAAL;IAAb;;IAEAiF,IAAI,CAACC,KAALD,GAAaR,QAAQ,IAAIF,aAAa,KAAK,OAAlBA,GAA4B,CAA5BA,GAAgC,CAAC,CAArC,CAArBU;IACAG,IAAI,CAACC,KAALD,GAAa,CAACX,QAAQ,GAAGC,WAAZ,KAA4BH,aAAa,KAAK,OAAlBA,GAA4B,CAA5BA,GAAgC,CAAC,CAA7D,CAAba;;IAEA,IAAIb,aAAa,KAAK,OAAtB,EAA+B;MAC3BoB,SAAS,GAAGb,SAAS,CAACc,KAAVd,CAAgBsB,IAA5BT;IADJ,OAEO;MACHA,SAAS,GAAGb,SAAS,CAACc,KAAVd,CAAgBuB,KAA5BV;IACH;EACJ;;EAED,IAAMhC,KAAK,GAAGkB,MAAM,CAACyB,GAAPzB,CAAW,iBAAK;IAAA;MAC1B9G,GAAG,EAAE,OAAOC,KAAP,KAAiB,QAAjB,IAA6B,OAAOA,KAAP,KAAiB,QAA9C,GAAyDA,KAAzD,aAAoEA,KAApE,CADqB;MAE1BA,KAAK,EAALA;IAF0B,GAGvB0H,SAAS,CAAC1H,KAAD,CAHc,GAIvBiH,IAJuB,GAKvBG,IALuB;EAAhB,EAAd;EAQA,OAAO;IACHzB,KAAK,EAALA,KADG;IAEHgC,SAAS,EAATA,SAFG;IAGHG,YAAY,EAAZA;EAHG,CAAP;AAhFG;;AAuFA,IAAMS,YAAY,GAAG,SAAfA,YAAe,CACxBC,QADwB,EAExB7G,KAFwB,EAGY;EACpC,IAAI,OAAO6G,QAAP,KAAkB,WAAlB,IAAiC,OAAOA,QAAP,KAAkB,UAAvD,EAAmE,OAAOA,QAAP;;EAEnE,IAAI7G,KAAK,CAAC8G,IAAN9G,KAAe,MAAnB,EAA2B;IACvB,IAAM+G,SAAS,GAAGC,UAAU,CAACH,QAAD,CAA5B;IAEA,OAAQ,aAAC;MAAA,OAAIE,SAAS,CAAC1G,CAAC,YAAY4G,IAAb5G,GAAoBA,CAApBA,GAAwB,IAAI4G,IAAJ,CAAS5G,CAAT,CAAzB,CAAb;IAAT;EACH;;EAED,OAAQ6G,MAAQ,CAACL,QAAD,CAAhB;AAZG;;AAeA,IAAMM,gBAAgB,GAAG,SAAnBA,gBAAmB,QAY1B;EAAA,IAXFC,KAWE,SAXFA,KAWE;EAAA,IAVFC,MAUE,SAVFA,MAUE;EAAA,IATFrH,KASE,SATFA,KASE;EAAA,IARF2E,IAQE,SARFA,IAQE;EAAA,IAPM2C,OAON,SAPFpC,MAOE;EACF,IAAMqC,UAAU,GAAG5D,OAAO,CAAS2D,OAAT,CAAP3D,GAA2B2D,OAA3B3D,GAAqCI,SAAxD;EACA,IAAMyD,SAAS,GAAGhE,SAAS,CAAC8D,OAAD,CAAT9D,GAAqB8D,OAArB9D,GAA+BO,SAAjD;EAEA,IAAMmB,MAAM,GAAGqC,UAAU,IAAI1D,aAAa,CAAC7D,KAAD,EAAQwH,SAAR,CAA1C;EAEA,IAAMnC,QAAQ,GAAG,eAAerF,KAAf,GAAuBD,WAAW,CAACC,KAAD,CAAlC,GAA4CA,KAA7D;EAEA,IAAMyH,KAAa,GACf9C,IAAI,KAAK,GAATA,GACMO,MAAM,CAACyB,GAAPzB,CAAW,iBAAK;IAAA;;IAAA,OAAK;MACjB9G,GAAG,YAAKC,KAAL,CADc;MAEjBqJ,EAAE,gBAAErC,QAAQ,CAAChH,KAAD,CAAV,mDAAqB,CAFN;MAGjBsJ,EAAE,gBAAEtC,QAAQ,CAAChH,KAAD,CAAV,mDAAqB,CAHN;MAIjBuJ,EAAE,EAAE,CAJa;MAKjBC,EAAE,EAAER;IALa,CAAL;EAAhB,EADN1C,GAQMO,MAAM,CAACyB,GAAPzB,CAAW,iBAAK;IAAA;;IAAA,OAAK;MACjB9G,GAAG,YAAKC,KAAL,CADc;MAEjBqJ,EAAE,EAAE,CAFa;MAGjBC,EAAE,EAAEP,KAHa;MAIjBQ,EAAE,gBAAEvC,QAAQ,CAAChH,KAAD,CAAV,mDAAqB,CAJN;MAKjBwJ,EAAE,gBAAExC,QAAQ,CAAChH,KAAD,CAAV,mDAAqB;IALN,CAAL;EAAhB,EATV;EAiBA,OAAOoJ,KAAP;AArCG;;ACxOP,IAAMK,QAAQ,GAAG,SAAXA,QAAW,OASW;EAAA;;EAAA,IARjBC,MAQiB,QARxB1J,KAQwB;EAAA,IAPxBwI,MAOwB,QAPxBA,MAOwB;EAAA,IANxBtB,KAMwB,QANxBA,KAMwB;EAAA,IALxBC,KAKwB,QALxBA,KAKwB;EAAA,IAJxBwC,QAIwB,QAJxBA,OAIwB;EAAA,IAHxB7B,YAGwB,QAHxBA,YAGwB;EAAA,IAFxB8B,UAEwB,QAFxBA,UAEwB;EAAA,IADxBC,aACwB,QADxBA,aACwB;EACxB,IAAMC,KAAK,GAAGC,QAAQ,EAAtB;EAEA,IAAM/J,KAAK,cAAGwI,MAAH,SAAGA,UAAH,WAAGA,GAAH,MAAGA,SAAM,CAAGkB,MAAH,CAAT,6CAAuBA,MAAlC;EAEA,IAAMM,KAAK,GAAGC,OAAO,CAAC,YAAM;IACxB,IAAMC,KAAK,GAAG;MAAEC,OAAO,EAAEN,aAAa,CAACM;IAAzB,CAAd;;IAEA,IAAI,CAACR,QAAL,EAAc;MACV,OAAO;QAAEO,KAAK,EAALA;MAAF,CAAP;IACH;;IAED,OAAO;MACHA,KAAK,oCAAOA,KAAP;QAAcE,MAAM,EAAE;MAAtB,EADF;MAEHT,OAAO,EAAE,iBAACU,KAAD;QAAA,OAAsDV,QAAO,CAACU,KAAD,EAAQrK,KAAR,CAA7D;MAAA;IAFN,CAAP;EAPiB,GAWlB,CAAC6J,aAAa,CAACM,OAAf,EAAwBR,QAAxB,EAAiC3J,KAAjC,CAXkB,CAArB;EAaA,OACIsK,oBAACC,QAAD,CAAUC,CAAV;IAAYC,SAAS,EAAEZ,aAAa,CAACY;EAArC,GAAoDT,KAApD,GACIM;IAAMjB,EAAE,EAAE,CAAV;IAAaC,EAAE,EAAEpC,KAAjB;IAAwBqC,EAAE,EAAE,CAA5B;IAA+BC,EAAE,EAAErC,KAAnC;IAA0C+C,KAAK,EAAEJ,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB7C;EAAlE,EADJ,EAEIqD,oBAACC,QAAD,CAAUnD,IAAV;IACIsD,gBAAgB,EAAE5C,YADtB;IAEI8B,UAAU,EAAEA,UAFhB;IAGIa,SAAS,EAAEZ,aAAa,CAACc,aAH7B;IAIIT,KAAK,EAAEJ,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB1C;EAJ5B,GAMKpH,KANL,CAFJ,CADJ;AA3BJ;;IA0CM4K,gBAAgB,GAAGC,IAAI,CAACpB,QAAD;;ACxC7B,IAAMqB,IAAI,GAAG,SAAPA,IAAO,OAyBP;EAAA,IAxBFxE,IAwBE,QAxBFA,IAwBE;EAAA,IAvBF3E,KAuBE,QAvBFA,KAuBE;EAAA,kBAtBFqG,CAsBE;EAAA,IAtBFA,CAsBE,uBAtBE,CAsBF;EAAA,kBArBFC,CAqBE;EAAA,IArBFA,CAqBE,uBArBE,CAqBF;EAAA,IApBF5G,MAoBE,QApBFA,MAoBE;EAAA,IAnBFkF,aAmBE,QAnBFA,aAmBE;EAAA,IAlBFC,UAkBE,QAlBFA,UAkBE;EAAA,yBAjBFC,QAiBE;EAAA,IAjBFA,QAiBE,8BAjBS,CAiBT;EAAA,4BAhBFC,WAgBE;EAAA,IAhBFA,WAgBE,iCAhBY,CAgBZ;EAAA,6BAfFC,YAeE;EAAA,IAfFA,YAeE,kCAfa,CAeb;EAAA,IAdF6B,MAcE,QAdFA,MAcE;EAAA,2BAbFuC,UAaE;EAAA,IAbFA,UAaE,gCAbWtB,gBAaX;EAAA,IAZFuB,MAYE,QAZFA,MAYE;EAAA,+BAXFC,cAWE;EAAA,IAXFA,cAWE,oCAXe,KAWf;EAAA,6BAVFC,YAUE;EAAA,IAVFA,YAUE,kCAVa,CAUb;EAAA,IATFvB,OASE,QATFA,OASE;EAAA,IARFwB,UAQE,QARFA,UAQE;EACF,IAAMrB,KAAK,GAAGC,QAAQ,EAAtB;EAEA,IAAMqB,WAAW,GAAGnB,OAAO,CAAC;IAAA,OAAM1B,YAAY,CAACC,MAAD,EAAS7G,KAAT,CAAlB;EAAD,GAAoC,CAAC6G,MAAD,EAAS7G,KAAT,CAApC,CAA3B;;EAHE,4BAKyC0E,qBAAqB,CAAC;IAC7DC,IAAI,EAAJA,IAD6D;IAE7D3E,KAAK,EAALA,KAF6D;IAG7D4E,aAAa,EAAbA,aAH6D;IAI7DC,UAAU,EAAVA,UAJ6D;IAK7DC,QAAQ,EAARA,QAL6D;IAM7DC,WAAW,EAAXA,WAN6D;IAO7DC,YAAY,EAAZA;EAP6D,CAAD,CAL9D;EAAA,IAKMhB,KALN,yBAKMA,KALN;EAAA,IAKagC,SALb,yBAKaA,SALb;EAAA,IAKwBG,YALxB,yBAKwBA,YALxB;;EAeF,IAAIuD,UAAU,GAAG,IAAjB;;EACA,IAAIL,MAAM,KAAKtF,SAAf,EAA0B;IACtB,IAAI4F,OAAO,GAAG,CAAd;IACA,IAAIC,OAAO,GAAG,CAAd;IACA,IAAIC,cAAc,GAAG,CAArB;IACA,IAAI5B,UAAJ;;IAEA,IAAItD,IAAI,KAAK,GAAb,EAAkB;MACdkF,cAAc,GAAG,CAAC,EAAlBA;MACAF,OAAO,GAAGJ,YAAVI;;MACA,IAAIL,cAAc,KAAK,OAAvB,EAAgC;QAC5BrB,UAAU,GAAG,OAAbA;QACA2B,OAAO,GAAGlK,MAAVkK;MAFJ,OAGO,IAAIN,cAAc,KAAK,QAAvB,EAAiC;QACpCrB,UAAU,GAAG,QAAbA;QACA2B,OAAO,GAAGlK,MAAM,GAAG,CAAnBkK;MAFG,OAGA,IAAIN,cAAc,KAAK,KAAvB,EAA8B;QACjCrB,UAAU,GAAG,KAAbA;MACH;IAXL,OAYO;MACH2B,OAAO,GAAGL,YAAVK;;MACA,IAAIN,cAAc,KAAK,OAAvB,EAAgC;QAC5BrB,UAAU,GAAG,OAAbA;MADJ,OAEO,IAAIqB,cAAc,KAAK,QAAvB,EAAiC;QACpCrB,UAAU,GAAG,QAAbA;QACA0B,OAAO,GAAGjK,MAAM,GAAG,CAAnBiK;MAFG,OAGA,IAAIL,cAAc,KAAK,KAAvB,EAA8B;QACjCrB,UAAU,GAAG,KAAbA;QACA0B,OAAO,GAAGjK,MAAViK;MACH;IACJ;;IAEDD,UAAU,GACNf;MACIG,SAAS,sBAAea,OAAf,eAA2BC,OAA3B,sBAA8CC,cAA9C,MADb;MAEI5B,UAAU,EAAEA,UAFhB;MAGIM,KAAK;QACDQ,gBAAgB,EAAE;MADjB,GAEEZ,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAFpB;IAHT,GAQK4D,MARL,CADJK;EAYH;;EA3DC,uBA6DwCI,eAAe,EA7DvD;EAAA,IA6DMC,OA7DN,oBA6DMA,OA7DN;EAAA,IA6DuBC,YA7DvB,oBA6DeC,MA7Df;;EA+DF,IAAM/B,aAAa,GAAGgC,SAAS,CAAC;IAC5BpB,SAAS,sBAAezC,CAAf,cAAoBC,CAApB,MADmB;IAE5B6D,MAAM,EAAExF,IAAI,KAAK,GAATA,GAAejF,MAAfiF,GAAwB,CAFJ;IAG5ByF,MAAM,EAAEzF,IAAI,KAAK,GAATA,GAAe,CAAfA,GAAmBjF,MAHC;IAI5BuK,MAAM,EAAED,YAJoB;IAK5BK,SAAS,EAAE,CAACN;EALgB,CAAD,CAA/B;EAQA,IAAMO,UAAU,GAAGC,aAAa,CAG9BvG,KAH8B,EAGvB;IACLlF,IAAI,EAAE,oBAAI;MAAA,OAAI0L,IAAI,CAACpM,GAAT;IADL;IAELqM,OAAO,EAAE,uBAAI;MAAA,OAAK;QACdjC,OAAO,EAAE,CADK;QAEdM,SAAS,sBAAe0B,IAAI,CAACnE,CAApB,cAAyBmE,IAAI,CAAClE,CAA9B,MAFK;QAGd0C,aAAa,sBAAewB,IAAI,CAAC9E,KAApB,cAA6B8E,IAAI,CAAC7E,KAAlC,sBAAmDX,YAAnD;MAHC,CAAL;IAFR;IAOL0F,IAAI,EAAE,oBAAI;MAAA,OAAK;QACXlC,OAAO,EAAE,CADE;QAEXM,SAAS,sBAAe0B,IAAI,CAACnE,CAApB,cAAyBmE,IAAI,CAAClE,CAA9B,MAFE;QAGX0C,aAAa,sBAAewB,IAAI,CAAC9E,KAApB,cAA6B8E,IAAI,CAAC7E,KAAlC,sBAAmDX,YAAnD;MAHF,CAAL;IAPL;IAYL2F,KAAK,EAAE,qBAAI;MAAA,OAAK;QACZnC,OAAO,EAAE,CADG;QAEZM,SAAS,sBAAe0B,IAAI,CAACnE,CAApB,cAAyBmE,IAAI,CAAClE,CAA9B,MAFG;QAGZ0C,aAAa,sBAAewB,IAAI,CAAC9E,KAApB,cAA6B8E,IAAI,CAAC7E,KAAlC,sBAAmDX,YAAnD;MAHD,CAAL;IAZN;IAiBL4F,MAAM,EAAE,sBAAI;MAAA,OAAK;QACbpC,OAAO,EAAE,CADI;QAEbM,SAAS,sBAAe0B,IAAI,CAACnE,CAApB,cAAyBmE,IAAI,CAAClE,CAA9B,MAFI;QAGb0C,aAAa,sBAAewB,IAAI,CAAC9E,KAApB,cAA6B8E,IAAI,CAAC7E,KAAlC,sBAAmDX,YAAnD;MAHA,CAAL;IAjBP;IAsBL6F,KAAK,EAAE;MACHrC,OAAO,EAAE;IADN,CAtBF;IAyBLyB,MAAM,EAAED,YAzBH;IA0BLK,SAAS,EAAE,CAACN;EA1BP,CAHuB,CAAhC;EAgCA,OACIpB,oBAACC,QAAD,CAAUC,CAAV;IAAYC,SAAS,EAAEZ,aAAa,CAACY,SAArC;IAAgD,eAAaU;EAA7D,GACKc,UAAU,CAAC,UAACQ,eAAD,EAAkBN,IAAlB,EAAwBO,MAAxB,EAAgCC,SAAhC,EAA8C;IACtD,OAAOrC,KAAK,CAACsC,aAANtC,CAAoBS,UAApBT;MACHqC,SAAS,EAATA,SADG;MAEHnE,MAAM,EAAE4C,WAFL;MAGHyB,MAAM,EAAElG,YAHL;MAIHmB,YAAY,EAAZA,YAJG;MAKH8B,UAAU,EAAEjC,SALT;MAMHkC,aAAa,EAAE4C;IANZ,GAOAN,IAPA,GAQCxC,OAAO,GAAG;MAAEA,OAAO,EAAPA;IAAF,CAAH,GAAiB,EARzB,EAAP;EADO,EADf,EAaIW,oBAACC,QAAD,CAAUtD,IAAV;IACIiD,KAAK,EAAEJ,KAAK,CAACxD,IAANwD,CAAW1D,MAAX0D,CAAkB7C,IAD7B;IAEIoC,EAAE,EAAE,CAFR;IAGIC,EAAE,EAAEO,aAAa,CAACiC,MAHtB;IAIIvC,EAAE,EAAE,CAJR;IAKIC,EAAE,EAAEK,aAAa,CAACkC;EALtB,EAbJ,EAoBKV,UApBL,CADJ;AAhIJ;;IA0JMyB,YAAY,GAAGjC,IAAI,CAACC,IAAD;IC/JZiC,aAAa,GAAG;EACzBxG,aAAa,EAAEyG,SAAS,CAACC,KAAVD,CAAgB,CAAC,QAAD,EAAW,OAAX,CAAhBA,CADU;EAEzBxG,UAAU,EAAEwG,SAAS,CAACE,SAAVF,CAAoB,CAC5BA,SAAS,CAACG,MADkB,EAE5BH,SAAS,CAACI,OAAVJ,CACIA,SAAS,CAACE,SAAVF,CAAoB,CAACA,SAAS,CAACG,MAAX,EAAmBH,SAAS,CAACK,MAA7B,EAAqCL,SAAS,CAACM,UAAVN,CAAqBpE,IAArBoE,CAArC,CAApBA,CADJA,CAF4B,EAK5BA,SAAS,CAACK,MALkB,CAApBL,CAFa;EASzBvG,QAAQ,EAAEuG,SAAS,CAACG,MATK;EAUzBzG,WAAW,EAAEsG,SAAS,CAACG,MAVE;EAWzBxG,YAAY,EAAEqG,SAAS,CAACG,MAXC;EAYzB3E,MAAM,EAAEwE,SAAS,CAACE,SAAVF,CAAoB,CAACA,SAAS,CAACO,IAAX,EAAiBP,SAAS,CAACK,MAA3B,CAApBL,CAZiB;EAazBjC,UAAU,EAAEiC,SAAS,CAACO,IAbG;EAczBvC,MAAM,EAAEgC,SAAS,CAACQ,IAdO;EAezBvC,cAAc,EAAE+B,SAAS,CAACC,KAAVD,CAAgB,CAAC,OAAD,EAAU,QAAV,EAAoB,KAApB,CAAhBA,CAfS;EAgBzB9B,YAAY,EAAE8B,SAAS,CAACG,MAhBC;EAiBzBhC,UAAU,EAAE6B,SAAS,CAACS;AAjBG;IAoBhBC,YAAY,GAAGV,SAAS,CAACW,KAAVX,CAAgBD,aAAhBC;IAEfY,SAAS,GAAG,CAAC,KAAD,EAAQ,OAAR,EAAiB,QAAjB,EAA2B,MAA3B;ICnBZC,IAAI,GAAGhD,IAAI,CACpB,gBAkBM;EAAA,IAjBFiD,MAiBE,QAjBFA,MAiBE;EAAA,IAhBFC,MAgBE,QAhBFA,MAgBE;EAAA,IAfFhF,KAeE,QAfFA,KAeE;EAAA,IAdFC,MAcE,QAdFA,MAcE;EAAA,IAbFd,GAaE,QAbFA,GAaE;EAAA,IAZFG,KAYE,QAZFA,KAYE;EAAA,IAXFF,MAWE,QAXFA,MAWE;EAAA,IAVFC,IAUE,QAVFA,IAUE;EACF,IAAM4F,IAAI,GAAG;IAAE9F,GAAG,EAAHA,GAAF;IAAOG,KAAK,EAALA,KAAP;IAAcF,MAAM,EAANA,MAAd;IAAsBC,IAAI,EAAJA;EAAtB,CAAb;EAEA,OACIkC,0CACKsD,SAAS,CAACtF,GAAVsF,CAAc,oBAAY;IACvB,IAAMtH,IAAI,GAAG0H,IAAI,CAAChH,QAAD,CAAjB;IAIA,IAAI,CAACV,IAAL,EAAW,OAAO,IAAP;IAEX,IAAM2H,OAAO,GAAGjH,QAAQ,KAAK,KAAbA,IAAsBA,QAAQ,KAAK,QAAnD;IACA,IAAMT,aAAa,GACfS,QAAQ,KAAK,KAAbA,IAAsBA,QAAQ,KAAK,MAAnCA,GAA4C,QAA5CA,GAAuD,OAD3D;IAGA,OACIsD,oBAACQ,YAAD;MACI/K,GAAG,EAAEiH;IADT,GAEQV,IAFR;MAGIA,IAAI,EAAE2H,OAAO,GAAG,GAAH,GAAS,GAH1B;MAIIjG,CAAC,EAAEhB,QAAQ,KAAK,OAAbA,GAAuB+B,KAAvB/B,GAA+B,CAJtC;MAKIiB,CAAC,EAAEjB,QAAQ,KAAK,QAAbA,GAAwBgC,MAAxBhC,GAAiC,CALxC;MAMIrF,KAAK,EAAEsM,OAAO,GAAGH,MAAH,GAAYC,MAN9B;MAOI1M,MAAM,EAAE4M,OAAO,GAAGlF,KAAH,GAAWC,MAP9B;MAQIzC,aAAa,EAAEA;IARnB,GADJ;EAXH,EADL,CADJ;AAtBgB;ICDX2H,QAAQ,GAAGrD,IAAI,CACxB,gBAUM;EAAA,IATFhB,aASE,QATFA,aASE;EACF,IAAMC,KAAK,GAAGC,QAAQ,EAAtB;EAEA,OAAOO,oBAACC,QAAD,CAAUtD,IAAV,oBAAmB4C,aAAnB,EAAuCC,KAAK,CAACqE,IAANrE,CAAW7C,IAAlD,EAAP;AAdoB;ICEfmH,SAAS,GAAGvD,IAAI,CAAC,gBAAkC;EAAA,IAA/BzB,KAA+B,QAA/BA,KAA+B;;EAAA,uBAClBqC,eAAe,EADG;EAAA,IACpDC,OADoD,oBACpDA,OADoD;EAAA,IACnCC,YADmC,oBAC3CC,MAD2C;;EAG5D,IAAMK,UAAU,GAAGC,aAAa,CAC5B9C,KAD4B,EAE5B;IACI3I,IAAI,EAAE,oBAAI;MAAA,OAAIwG,IAAI,CAAClH,GAAT;IADd;IAEIqM,OAAO,EAAE,uBAAI;MAAA,OAAK;QACdjC,OAAO,EAAE,CADK;QAEdd,EAAE,EAAEpC,IAAI,CAACoC,EAFK;QAGdC,EAAE,EAAErC,IAAI,CAACqC,EAHK;QAIdC,EAAE,EAAEtC,IAAI,CAACsC,EAJK;QAKdC,EAAE,EAAEvC,IAAI,CAACuC;MALK,CAAL;IAFjB;IASI6C,IAAI,EAAE,oBAAI;MAAA,OAAK;QACXlC,OAAO,EAAE,CADE;QAEXd,EAAE,EAAEpC,IAAI,CAACoC,EAFE;QAGXC,EAAE,EAAErC,IAAI,CAACqC,EAHE;QAIXC,EAAE,EAAEtC,IAAI,CAACsC,EAJE;QAKXC,EAAE,EAAEvC,IAAI,CAACuC;MALE,CAAL;IATd;IAgBI8C,KAAK,EAAE,qBAAI;MAAA,OAAK;QACZnC,OAAO,EAAE,CADG;QAEZd,EAAE,EAAEpC,IAAI,CAACoC,EAFG;QAGZC,EAAE,EAAErC,IAAI,CAACqC,EAHG;QAIZC,EAAE,EAAEtC,IAAI,CAACsC,EAJG;QAKZC,EAAE,EAAEvC,IAAI,CAACuC;MALG,CAAL;IAhBf;IAuBI+C,MAAM,EAAE,sBAAI;MAAA,OAAK;QACbpC,OAAO,EAAE,CADI;QAEbd,EAAE,EAAEpC,IAAI,CAACoC,EAFI;QAGbC,EAAE,EAAErC,IAAI,CAACqC,EAHI;QAIbC,EAAE,EAAEtC,IAAI,CAACsC,EAJI;QAKbC,EAAE,EAAEvC,IAAI,CAACuC;MALI,CAAL;IAvBhB;IA8BIgD,KAAK,EAAE;MACHrC,OAAO,EAAE;IADN,CA9BX;IAiCIyB,MAAM,EAAED,YAjCZ;IAkCIK,SAAS,EAAE,CAACN;EAlChB,CAF4B,CAAhC;EAwCA,OACIpB,+BACK2B,UAAU,CAAC,UAACpC,aAAD,EAAgB5C,IAAhB;IAAA,OACRqD,oBAAC4D,QAAD,oBAAcjH,IAAd;MAAoBlH,GAAG,EAAEkH,IAAI,CAAClH,GAA9B;MAAmC8J,aAAa,EAAEA;IAAlD,GADQ;EAAD,EADf,CADJ;AA3CyB;ICDhBwE,IAAI,GAAGxD,IAAI,CACpB,gBAcM;EAAA,IAbF9B,KAaE,QAbFA,KAaE;EAAA,IAZFC,MAYE,QAZFA,MAYE;EAAA,IAXF8E,MAWE,QAXFA,MAWE;EAAA,IAVFC,MAUE,QAVFA,MAUE;EAAA,IATFO,OASE,QATFA,OASE;EAAA,IARFC,OAQE,QARFA,OAQE;EACF,IAAMC,MAAM,GAAGvE,OAAO,CAAC,YAAM;IACzB,IAAI,CAAC6D,MAAL,EAAa,OAAO,KAAP;IAEb,OAAOhF,gBAAgB,CAAC;MACpBC,KAAK,EAALA,KADoB;MAEpBC,MAAM,EAANA,MAFoB;MAGpBrH,KAAK,EAAEmM,MAHa;MAIpBxH,IAAI,EAAE,GAJc;MAKpBO,MAAM,EAAEyH;IALY,CAAD,CAAvB;EAHkB,GAUnB,CAACR,MAAD,EAASQ,OAAT,EAAkBvF,KAAlB,EAAyBC,MAAzB,CAVmB,CAAtB;EAYA,IAAMyF,MAAM,GAAGxE,OAAO,CAAC,YAAM;IACzB,IAAI,CAAC8D,MAAL,EAAa,OAAO,KAAP;IAEb,OAAOjF,gBAAgB,CAAC;MACpBC,KAAK,EAALA,KADoB;MAEpBC,MAAM,EAANA,MAFoB;MAGpBrH,KAAK,EAAEoM,MAHa;MAIpBzH,IAAI,EAAE,GAJc;MAKpBO,MAAM,EAAE0H;IALY,CAAD,CAAvB;EAHkB,GAUnB,CAACvF,MAAD,EAASD,KAAT,EAAgBgF,MAAhB,EAAwBQ,OAAxB,CAVmB,CAAtB;EAYA,OACIjE,0CACKkE,MAAM,IAAIlE,oBAAC8D,SAAD;IAAWhF,KAAK,EAAEoF;EAAlB,EADf,EAEKC,MAAM,IAAInE,oBAAC8D,SAAD;IAAWhF,KAAK,EAAEqF;EAAlB,EAFf,CADJ;AAxCgB;;ICOXC,kBAAkB,GAAG,SAArBA,kBAAqB,CAC9BC,GAD8B,QAsC7B;EAAA;;EAAA,IAnCGrI,IAmCH,QAnCGA,IAmCH;EAAA,IAlCG3E,KAkCH,QAlCGA,KAkCH;EAAA,kBAjCGqG,CAiCH;EAAA,IAjCGA,CAiCH,uBAjCO,CAiCP;EAAA,kBAhCGC,CAgCH;EAAA,IAhCGA,CAgCH,uBAhCO,CAgCP;EAAA,IA/BG5G,MA+BH,QA/BGA,MA+BH;EAAA,IA7BGkF,aA6BH,QA7BGA,aA6BH;EAAA,IA5BGC,UA4BH,QA5BGA,UA4BH;EAAA,yBA3BGC,QA2BH;EAAA,IA3BGA,QA2BH,8BA3Bc,CA2Bd;EAAA,4BA1BGC,WA0BH;EAAA,IA1BGA,WA0BH,iCA1BiB,CA0BjB;EAAA,6BAzBGC,YAyBH;EAAA,IAzBGA,YAyBH,kCAzBkB,CAyBlB;EAAA,IAxBWiI,OAwBX,QAxBGpG,MAwBH;EAAA,IAtBGwC,MAsBH,QAtBGA,MAsBH;EAAA,+BArBGC,cAqBH;EAAA,IArBGA,cAqBH,oCArBoB,KAqBpB;EAAA,6BApBGC,YAoBH;EAAA,IApBGA,YAoBH,kCApBkB,CAoBlB;EAAA,IAlBGpB,KAkBH,QAlBGA,KAkBH;;EAAA,4BAC0CzD,qBAAqB,CAAC;IAC7DC,IAAI,EAAJA,IAD6D;IAE7D3E,KAAK,EAALA,KAF6D;IAG7D4E,aAAa,EAAbA,aAH6D;IAI7DC,UAAU,EAAVA,UAJ6D;IAK7DC,QAAQ,EAARA,QAL6D;IAM7DC,WAAW,EAAXA,WAN6D;IAO7DC,YAAY,EAAZA,YAP6D;IAQ7DC,MAAM,EAAE;EARqD,CAAD,CAD/D;EAAA,IACOjB,KADP,yBACOA,KADP;EAAA,IACcgC,SADd,yBACcA,SADd;EAAA,IACyBG,YADzB,yBACyBA,YADzB;;EAYD6G,GAAG,CAACE,IAAJF;EACAA,GAAG,CAACjH,SAAJiH,CAAc3G,CAAd2G,EAAiB1G,CAAjB0G;EAEAA,GAAG,CAAChH,SAAJgH,GAAgBhH,SAAhBgH;EACAA,GAAG,CAAC7G,YAAJ6G,GAAmB7G,YAAnB6G;EACAA,GAAG,CAACG,IAAJH,aAAc7E,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB1C,IAAjB0C,CAAsBiF,QAApC,gBAAkDjF,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB1C,IAAjB0C,CAAsBkF,UAAxE;;EAEA,IAAI,0BAAClF,KAAK,CAACxD,IAANwD,CAAW1D,MAAX0D,CAAkB7C,IAAlB6C,CAAuBmF,WAAxB,yEAAuC,CAAvC,IAA4C,CAAhD,EAAmD;IAC/CN,GAAG,CAACO,SAAJP,GAAgBzI,MAAM,CAAC4D,KAAK,CAACxD,IAANwD,CAAW1D,MAAX0D,CAAkB7C,IAAlB6C,CAAuBmF,WAAxB,CAAtBN;IACAA,GAAG,CAACQ,OAAJR,GAAc,QAAdA;;IAEA,IAAI7E,KAAK,CAACxD,IAANwD,CAAW1D,MAAX0D,CAAkB7C,IAAlB6C,CAAuBsF,MAA3B,EAAmC;MAC/BT,GAAG,CAACU,WAAJV,GAAkB7E,KAAK,CAACxD,IAANwD,CAAW1D,MAAX0D,CAAkB7C,IAAlB6C,CAAuBsF,MAAzCT;IACH;;IAEDA,GAAG,CAACW,SAAJX;IACAA,GAAG,CAACY,MAAJZ,CAAW,CAAXA,EAAc,CAAdA;IACAA,GAAG,CAACa,MAAJb,CAAWrI,IAAI,KAAK,GAATA,GAAejF,MAAfiF,GAAwB,CAAnCqI,EAAsCrI,IAAI,KAAK,GAATA,GAAe,CAAfA,GAAmBjF,MAAzDsN;IACAA,GAAG,CAACS,MAAJT;EACH;;EAED,IAAMnG,MAAM,GAAG,OAAOoG,OAAP,KAAmB,UAAnB,GAAgCA,OAAhC,GAA0C,UAAC5O,KAAD;IAAA,iBAAuBA,KAAvB;EAAzD;EAEA2F,KAAK,CAACpE,OAANoE,CAAc,gBAAQ;IAAA;;IAClB,IAAI,0BAACmE,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB7C,IAAjB6C,CAAsBmF,WAAvB,yEAAsC,CAAtC,IAA2C,CAA/C,EAAkD;MAC9CN,GAAG,CAACO,SAAJP,GAAgBzI,MAAM,CAAC4D,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB7C,IAAjB6C,CAAsBmF,WAAvB,CAAtBN;MACAA,GAAG,CAACQ,OAAJR,GAAc,QAAdA;;MAEA,IAAI7E,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB7C,IAAjB6C,CAAsBsF,MAA1B,EAAkC;QAC9BT,GAAG,CAACU,WAAJV,GAAkB7E,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB7C,IAAjB6C,CAAsBsF,MAAxCT;MACH;;MAEDA,GAAG,CAACW,SAAJX;MACAA,GAAG,CAACY,MAAJZ,CAAWxC,IAAI,CAACnE,CAAhB2G,EAAmBxC,IAAI,CAAClE,CAAxB0G;MACAA,GAAG,CAACa,MAAJb,CAAWxC,IAAI,CAACnE,CAALmE,GAASA,IAAI,CAACjF,KAAzByH,EAAgCxC,IAAI,CAAClE,CAALkE,GAASA,IAAI,CAAChF,KAA9CwH;MACAA,GAAG,CAACS,MAAJT;IACH;;IAED,IAAM3O,KAAK,GAAGwI,MAAM,CAAC2D,IAAI,CAACnM,KAAN,CAApB;IAEA2O,GAAG,CAACE,IAAJF;IACAA,GAAG,CAACjH,SAAJiH,CAAcxC,IAAI,CAACnE,CAALmE,GAASA,IAAI,CAAC9E,KAA5BsH,EAAmCxC,IAAI,CAAClE,CAALkE,GAASA,IAAI,CAAC7E,KAAjDqH;IACAA,GAAG,CAAC9B,MAAJ8B,CAAWc,gBAAgB,CAAC9I,YAAD,CAA3BgI;;IAEA,IAAI7E,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB1C,IAAjB0C,CAAsB4F,IAA1B,EAAgC;MAC5Bf,GAAG,CAACgB,SAAJhB,GAAgB7E,KAAK,CAACxD,IAANwD,CAAWnE,KAAXmE,CAAiB1C,IAAjB0C,CAAsB4F,IAAtCf;IACH;;IAEDA,GAAG,CAACiB,QAAJjB,CAAakB,MAAM,CAAC7P,KAAD,CAAnB2O,EAA4B,CAA5BA,EAA+B,CAA/BA;IACAA,GAAG,CAACmB,OAAJnB;EA1BJ;;EA6BA,IAAI3D,MAAM,KAAKtF,SAAf,EAA0B;IACtB,IAAI4F,OAAO,GAAG,CAAd;IACA,IAAIC,OAAO,GAAG,CAAd;IACA,IAAIC,cAAc,GAAG,CAArB;IACA,IAAI7D,UAA0B,GAAG,QAAjC;;IAEA,IAAIrB,IAAI,KAAK,GAAb,EAAkB;MACdkF,cAAc,GAAG,CAAC,EAAlBA;MACAF,OAAO,GAAGJ,YAAVI;;MACA,IAAIL,cAAc,KAAK,OAAvB,EAAgC;QAC5BtD,UAAS,GAAG,OAAZA;QACA4D,OAAO,GAAGlK,MAAVkK;MAFJ,OAGO,IAAIN,cAAc,KAAK,QAAvB,EAAiC;QACpCtD,UAAS,GAAG,QAAZA;QACA4D,OAAO,GAAGlK,MAAM,GAAG,CAAnBkK;MAFG,OAGA,IAAIN,cAAc,KAAK,KAAvB,EAA8B;QACjCtD,UAAS,GAAG,KAAZA;MACH;IAXL,OAYO;MACH4D,OAAO,GAAGL,YAAVK;;MACA,IAAIN,cAAc,KAAK,OAAvB,EAAgC;QAC5BtD,UAAS,GAAG,OAAZA;MADJ,OAEO,IAAIsD,cAAc,KAAK,QAAvB,EAAiC;QACpCtD,UAAS,GAAG,QAAZA;QACA2D,OAAO,GAAGjK,MAAM,GAAG,CAAnBiK;MAFG,OAGA,IAAIL,cAAc,KAAK,KAAvB,EAA8B;QACjCtD,UAAS,GAAG,KAAZA;QACA2D,OAAO,GAAGjK,MAAViK;MACH;IACJ;;IAEDqD,GAAG,CAACjH,SAAJiH,CAAcrD,OAAdqD,EAAuBpD,OAAvBoD;IACAA,GAAG,CAAC9B,MAAJ8B,CAAWc,gBAAgB,CAACjE,cAAD,CAA3BmD;IACAA,GAAG,CAACG,IAAJH,aACI7E,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuBiG,UAAvBjG,aAAuCA,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuBiG,UAA9D,SAA8E,EADlF,SAEGjG,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuBiF,QAF1B,gBAEwCjF,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuBkF,UAF/D;;IAIA,IAAIlF,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuB4F,IAA3B,EAAiC;MAC7Bf,GAAG,CAACgB,SAAJhB,GAAgB7E,KAAK,CAACxD,IAANwD,CAAWkB,MAAXlB,CAAkB1C,IAAlB0C,CAAuB4F,IAAvCf;IACH;;IAEDA,GAAG,CAAChH,SAAJgH,GAAgBhH,UAAhBgH;IACAA,GAAG,CAAC7G,YAAJ6G,GAAmB,QAAnBA;IACAA,GAAG,CAACiB,QAAJjB,CAAa3D,MAAb2D,EAAqB,CAArBA,EAAwB,CAAxBA;EACH;;EAEDA,GAAG,CAACmB,OAAJnB;AACH;;IAEYqB,kBAAkB,GAAG,SAArBA,kBAAqB,CAC9BrB,GAD8B,SAyB7B;EAAA,IAtBGb,MAsBH,SAtBGA,MAsBH;EAAA,IArBGC,MAqBH,SArBGA,MAqBH;EAAA,IApBGhF,KAoBH,SApBGA,KAoBH;EAAA,IAnBGC,MAmBH,SAnBGA,MAmBH;EAAA,IAjBGd,GAiBH,SAjBGA,GAiBH;EAAA,IAhBGG,KAgBH,SAhBGA,KAgBH;EAAA,IAfGF,MAeH,SAfGA,MAeH;EAAA,IAdGC,IAcH,SAdGA,IAcH;EAAA,IAZG0B,KAYH,SAZGA,KAYH;EACD,IAAMkE,IAAI,GAAG;IAAE9F,GAAG,EAAHA,GAAF;IAAOG,KAAK,EAALA,KAAP;IAAcF,MAAM,EAANA,MAAd;IAAsBC,IAAI,EAAJA;EAAtB,CAAb;EAEAwF,SAAS,CAACrM,OAAVqM,CAAkB,oBAAY;IAC1B,IAAMtH,IAAI,GAAG0H,IAAI,CAAChH,QAAD,CAAjB;IAIA,IAAI,CAACV,IAAL,EAAW,OAAO,IAAP;IAEX,IAAM2H,OAAO,GAAGjH,QAAQ,KAAK,KAAbA,IAAsBA,QAAQ,KAAK,QAAnD;IACA,IAAMT,aAAa,GAAGS,QAAQ,KAAK,KAAbA,IAAsBA,QAAQ,KAAK,MAAnCA,GAA4C,QAA5CA,GAAuD,OAA7E;IACA,IAAMrF,KAAK,GAAGsM,OAAO,GAAGH,MAAH,GAAYC,MAAjC;IACA,IAAMvF,MAAM,GAAGD,YAAY,CAACjC,IAAI,CAACkC,MAAN,EAAc7G,KAAd,CAA3B;IAEA+M,kBAAkB,CAACC,GAAD,oCACXrI,IADW;MAEdA,IAAI,EAAE2H,OAAO,GAAG,GAAH,GAAS,GAFR;MAGdjG,CAAC,EAAEhB,QAAQ,KAAK,OAAbA,GAAuB+B,KAAvB/B,GAA+B,CAHpB;MAIdiB,CAAC,EAAEjB,QAAQ,KAAK,QAAbA,GAAwBgC,MAAxBhC,GAAiC,CAJtB;MAKdrF,KAAK,EAALA,KALc;MAMd6G,MAAM,EAANA,MANc;MAOdnH,MAAM,EAAE4M,OAAO,GAAGlF,KAAH,GAAWC,MAPZ;MAQdzC,aAAa,EAAbA,aARc;MASduD,KAAK,EAALA;IATc,GAAlB4E;EAZJ;AAwBH;;IAEYuB,uBAAuB,GAAG,SAA1BA,uBAA0B,CACnCtB,GADmC,SAelC;EAAA,IAZG5F,KAYH,SAZGA,KAYH;EAAA,IAXGC,MAWH,SAXGA,MAWH;EAAA,IAVGrH,KAUH,SAVGA,KAUH;EAAA,IATG2E,IASH,SATGA,IASH;EAAA,IARGO,MAQH,SARGA,MAQH;EACD,IAAMuC,KAAK,GAAGN,gBAAgB,CAAC;IAAEC,KAAK,EAALA,KAAF;IAASC,MAAM,EAANA,MAAT;IAAiBrH,KAAK,EAALA,KAAjB;IAAwB2E,IAAI,EAAJA,IAAxB;IAA8BO,MAAM,EAANA;EAA9B,CAAD,CAA9B;EAEAuC,KAAK,CAAC7H,OAAN6H,CAAc,gBAAQ;IAClBuF,GAAG,CAACW,SAAJX;IACAA,GAAG,CAACY,MAAJZ,CAAW1H,IAAI,CAACoC,EAAhBsF,EAAoB1H,IAAI,CAACsC,EAAzBoF;IACAA,GAAG,CAACa,MAAJb,CAAW1H,IAAI,CAACqC,EAAhBqF,EAAoB1H,IAAI,CAACuC,EAAzBmF;IACAA,GAAG,CAACS,MAAJT;EAJJ;AAMH","names":["_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","getOwnPropertyDescriptors","defineProperties","centerScale","scale","bandwidth","offset","round","Math","d","timeByType","millisecond","timeMillisecond","utcMillisecond","second","timeSecond","utcSecond","minute","timeMinute","utcMinute","hour","timeHour","utcHour","day","timeDay","utcDay","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","month","timeMonth","utcMonth","year","timeYear","utcYear","timeTypes","timeIntervalRegexp","RegExp","join","isInteger","isFinite","floor","isArray","Array","getScaleTicks","spec","undefined","ticks","matches","match","timeType","useUTC","interval","every","Number","Error","domain","computeCartesianTicks","axis","ticksPosition","tickValues","tickSize","tickPadding","tickRotation","engine","values","textProps","textPropsByEngine","position","line","lineX","lineY","text","textX","textY","isRTL","document","dir","translate","textAlign","align","center","textBaseline","baseline","x","y","top","bottom","left","right","map","getFormatter","format","type","formatter","timeFormat","Date","d3Format","computeGridLines","width","height","_values","lineValues","lineCount","lines","x1","x2","y1","y2","AxisTick","_value","onClick","textAnchor","animatedProps","theme","useTheme","props","useMemo","style","opacity","cursor","event","React","animated","g","transform","dominantBaseline","textTransform","memoizedAxisTick","memo","Axis","renderTick","legend","legendPosition","legendOffset","ariaHidden","formatValue","legendNode","legendX","legendY","legendRotation","useMotionConfig","animate","springConfig","config","useSpring","lineX2","lineY2","immediate","transition","useTransition","tick","initial","from","enter","update","leave","transitionProps","_state","tickIndex","createElement","rotate","memoizedAxis","axisPropTypes","PropTypes","oneOf","oneOfType","number","arrayOf","string","instanceOf","func","node","bool","axisPropType","shape","positions","Axes","xScale","yScale","axes","isXAxis","GridLine","grid","GridLines","Grid","xValues","yValues","xLines","yLines","renderAxisToCanvas","ctx","_format","save","font","fontSize","fontFamily","strokeWidth","lineWidth","lineCap","stroke","strokeStyle","beginPath","moveTo","lineTo","degreesToRadians","fill","fillStyle","fillText","String","restore","fontWeight","renderAxesToCanvas","renderGridLinesToCanvas"],"sources":["D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\defineProperty.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\objectSpread2.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\compute.ts","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\AxisTick.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\Axis.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\props.ts","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\Axes.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\GridLine.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\GridLines.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\components\\Grid.tsx","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\axes\\src\\canvas.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeDay,\n    utcDay,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n} from 'd3-time'\nimport { timeFormat } from 'd3-time-format'\nimport { format as d3Format } from 'd3-format'\n// @ts-ignore\nimport { textPropsByEngine } from '@nivo/core'\nimport {\n    AxisValue,\n    Point,\n    TicksSpec,\n    AnyScale,\n    ScaleWithBandwidth,\n    ValueFormatter,\n    Line,\n} from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nconst isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const getScaleTicks = <Value extends AxisValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n\n        if (typeof spec === 'string' && 'useUTC' in scale) {\n            // time interval\n            const matches = spec.match(timeIntervalRegexp)\n            if (matches) {\n                // UTC is used as it's more predictible\n                // however local time could be used too\n                // let's see how it fits users' requirements\n                const timeType = timeByType[matches[2]][scale.useUTC ? 1 : 0]\n\n                if (matches[1] === undefined) {\n                    return scale.ticks(timeType)\n                }\n\n                const interval = timeType.every(Number(matches[1]))\n\n                if (interval) {\n                    return scale.ticks(interval)\n                }\n            }\n\n            throw new Error(`Invalid tickValues: ${spec}`)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n\nexport const computeCartesianTicks = <Value extends AxisValue>({\n    axis,\n    scale,\n    ticksPosition,\n    tickValues,\n    tickSize,\n    tickPadding,\n    tickRotation,\n    engine = 'svg',\n}: {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    ticksPosition?: 'after' | 'before'\n    tickValues?: TicksSpec<Value>\n    tickSize: number\n    tickPadding: number\n    tickRotation: number\n    engine?: 'svg' | 'canvas'\n}) => {\n    const values = getScaleTicks(scale, tickValues)\n\n    const textProps = textPropsByEngine[engine]\n\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n    const line = { lineX: 0, lineY: 0 }\n    const text = { textX: 0, textY: 0 }\n\n    const isRTL = typeof document === 'object' ? document.dir === 'rtl' : false\n    let translate: (value: Value) => Point\n    let textAlign: CanvasTextAlign = textProps.align.center\n    let textBaseline: CanvasTextBaseline = textProps.baseline.center\n\n    if (axis === 'x') {\n        translate = d => ({ x: position(d) ?? 0, y: 0 })\n\n        line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textBaseline = textProps.baseline.top\n        } else {\n            textBaseline = textProps.baseline.bottom\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation < 0) ||\n            (ticksPosition === 'before' && tickRotation > 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'left' : 'right']\n            textBaseline = textProps.baseline.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation > 0) ||\n            (ticksPosition === 'before' && tickRotation < 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'right' : 'left']\n            textBaseline = textProps.baseline.center\n        }\n    } else {\n        translate = d => ({ x: 0, y: position(d) ?? 0 })\n\n        line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textAlign = textProps.align.left\n        } else {\n            textAlign = textProps.align.right\n        }\n    }\n\n    const ticks = values.map(value => ({\n        key: typeof value === 'number' || typeof value === 'string' ? value : `${value}`,\n        value,\n        ...translate(value),\n        ...line,\n        ...text,\n    }))\n\n    return {\n        ticks,\n        textAlign,\n        textBaseline,\n    }\n}\n\nexport const getFormatter = <Value extends AxisValue>(\n    format: string | ValueFormatter<Value> | undefined,\n    scale: AnyScale\n): ValueFormatter<Value> | undefined => {\n    if (typeof format === 'undefined' || typeof format === 'function') return format\n\n    if (scale.type === 'time') {\n        const formatter = timeFormat(format)\n\n        return (d => formatter(d instanceof Date ? d : new Date(d))) as ValueFormatter<Value>\n    }\n\n    return (d3Format(format) as unknown) as ValueFormatter<Value>\n}\n\nexport const computeGridLines = <Value extends AxisValue>({\n    width,\n    height,\n    scale,\n    axis,\n    values: _values,\n}: {\n    width: number\n    height: number\n    scale: AnyScale\n    axis: 'x' | 'y'\n    values?: TicksSpec<Value>\n}) => {\n    const lineValues = isArray<number>(_values) ? _values : undefined\n    const lineCount = isInteger(_values) ? _values : undefined\n\n    const values = lineValues || getScaleTicks(scale, lineCount)\n\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n\n    const lines: Line[] =\n        axis === 'x'\n            ? values.map(value => ({\n                  key: `${value}`,\n                  x1: position(value) ?? 0,\n                  x2: position(value) ?? 0,\n                  y1: 0,\n                  y2: height,\n              }))\n            : values.map(value => ({\n                  key: `${value}`,\n                  x1: 0,\n                  x2: width,\n                  y1: position(value) ?? 0,\n                  y2: position(value) ?? 0,\n              }))\n\n    return lines\n}\n","import React, { useMemo, memo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { AxisTickProps, AxisValue } from '../types'\n\nconst AxisTick = <Value extends AxisValue>({\n    value: _value,\n    format,\n    lineX,\n    lineY,\n    onClick,\n    textBaseline,\n    textAnchor,\n    animatedProps,\n}: AxisTickProps<Value>) => {\n    const theme = useTheme()\n\n    const value = format?.(_value) ?? _value\n\n    const props = useMemo(() => {\n        const style = { opacity: animatedProps.opacity }\n\n        if (!onClick) {\n            return { style }\n        }\n\n        return {\n            style: { ...style, cursor: 'pointer' },\n            onClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => onClick(event, value),\n        }\n    }, [animatedProps.opacity, onClick, value])\n\n    return (\n        <animated.g transform={animatedProps.transform} {...props}>\n            <line x1={0} x2={lineX} y1={0} y2={lineY} style={theme.axis.ticks.line} />\n            <animated.text\n                dominantBaseline={textBaseline}\n                textAnchor={textAnchor}\n                transform={animatedProps.textTransform}\n                style={theme.axis.ticks.text}\n            >\n                {value}\n            </animated.text>\n        </animated.g>\n    )\n}\n\nconst memoizedAxisTick = memo(AxisTick) as typeof AxisTick\n\nexport { memoizedAxisTick as AxisTick }\n","import React, { useMemo, memo } from 'react'\nimport { useSpring, useTransition, animated } from '@react-spring/web'\nimport { useTheme, useMotionConfig } from '@nivo/core'\nimport { computeCartesianTicks, getFormatter } from '../compute'\nimport { AxisTick } from './AxisTick'\nimport { AnyScale, AxisProps, AxisValue } from '../types'\n\nconst Axis = <Value extends AxisValue>({\n    axis,\n    scale,\n    x = 0,\n    y = 0,\n    length,\n    ticksPosition,\n    tickValues,\n    tickSize = 5,\n    tickPadding = 5,\n    tickRotation = 0,\n    format,\n    renderTick = AxisTick,\n    legend,\n    legendPosition = 'end',\n    legendOffset = 0,\n    onClick,\n    ariaHidden,\n}: AxisProps<Value> & {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    x?: number\n    y?: number\n    length: number\n    onClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>, value: Value | string) => void\n}) => {\n    const theme = useTheme()\n\n    const formatValue = useMemo(() => getFormatter(format, scale), [format, scale])\n\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n    })\n\n    let legendNode = null\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAnchor\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n                legendX = length\n            }\n        }\n\n        legendNode = (\n            <text\n                transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                textAnchor={textAnchor}\n                style={{\n                    dominantBaseline: 'central',\n                    ...theme.axis.legend.text,\n                }}\n            >\n                {legend}\n            </text>\n        )\n    }\n\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        transform: `translate(${x},${y})`,\n        lineX2: axis === 'x' ? length : 0,\n        lineY2: axis === 'x' ? 0 : length,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const transition = useTransition<\n        typeof ticks[0],\n        { opacity: number; transform: string; textTransform: string }\n    >(ticks, {\n        keys: tick => tick.key,\n        initial: tick => ({\n            opacity: 1,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        from: tick => ({\n            opacity: 0,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        enter: tick => ({\n            opacity: 1,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        update: tick => ({\n            opacity: 1,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        leave: {\n            opacity: 0,\n        },\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.g transform={animatedProps.transform} aria-hidden={ariaHidden}>\n            {transition((transitionProps, tick, _state, tickIndex) => {\n                return React.createElement(renderTick, {\n                    tickIndex,\n                    format: formatValue,\n                    rotate: tickRotation,\n                    textBaseline,\n                    textAnchor: textAlign,\n                    animatedProps: transitionProps,\n                    ...tick,\n                    ...(onClick ? { onClick } : {}),\n                })\n            })}\n            <animated.line\n                style={theme.axis.domain.line}\n                x1={0}\n                x2={animatedProps.lineX2}\n                y1={0}\n                y2={animatedProps.lineY2}\n            />\n            {legendNode}\n        </animated.g>\n    )\n}\n\nconst memoizedAxis = memo(Axis) as typeof Axis\n\nexport { memoizedAxis as Axis }\n","import PropTypes from 'prop-types'\n\nexport const axisPropTypes = {\n    ticksPosition: PropTypes.oneOf(['before', 'after']),\n    tickValues: PropTypes.oneOfType([\n        PropTypes.number,\n        PropTypes.arrayOf(\n            PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.instanceOf(Date)])\n        ),\n        PropTypes.string,\n    ]),\n    tickSize: PropTypes.number,\n    tickPadding: PropTypes.number,\n    tickRotation: PropTypes.number,\n    format: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),\n    renderTick: PropTypes.func,\n    legend: PropTypes.node,\n    legendPosition: PropTypes.oneOf(['start', 'middle', 'end']),\n    legendOffset: PropTypes.number,\n    ariaHidden: PropTypes.bool,\n}\n\nexport const axisPropType = PropTypes.shape(axisPropTypes)\n\nexport const positions = ['top', 'right', 'bottom', 'left'] as const\n","import React, { memo } from 'react'\nimport { Axis } from './Axis'\nimport { positions } from '../props'\nimport { AnyScale, AxisProps, AxisValue } from '../types'\n\nexport const Axes = memo(\n    <X extends AxisValue, Y extends AxisValue>({\n        xScale,\n        yScale,\n        width,\n        height,\n        top,\n        right,\n        bottom,\n        left,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: AxisProps<X>\n        right?: AxisProps<Y>\n        bottom?: AxisProps<X>\n        left?: AxisProps<Y>\n    }) => {\n        const axes = { top, right, bottom, left }\n\n        return (\n            <>\n                {positions.map(position => {\n                    const axis = axes[position] as typeof position extends 'bottom' | 'top'\n                        ? AxisProps<X> | undefined\n                        : AxisProps<Y> | undefined\n\n                    if (!axis) return null\n\n                    const isXAxis = position === 'top' || position === 'bottom'\n                    const ticksPosition =\n                        position === 'top' || position === 'left' ? 'before' : 'after'\n\n                    return (\n                        <Axis\n                            key={position}\n                            {...axis}\n                            axis={isXAxis ? 'x' : 'y'}\n                            x={position === 'right' ? width : 0}\n                            y={position === 'bottom' ? height : 0}\n                            scale={isXAxis ? xScale : yScale}\n                            length={isXAxis ? width : height}\n                            ticksPosition={ticksPosition}\n                        />\n                    )\n                })}\n            </>\n        )\n    }\n)\n","import React, { memo } from 'react'\nimport { SpringValues, animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\n\nexport const GridLine = memo(\n    ({\n        animatedProps,\n    }: {\n        animatedProps: SpringValues<{\n            opacity: number\n            x1: number\n            x2: number\n            y1: number\n            y2: number\n        }>\n    }) => {\n        const theme = useTheme()\n\n        return <animated.line {...animatedProps} {...(theme.grid.line as unknown)} />\n    }\n)\n","import React, { memo } from 'react'\nimport { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { GridLine } from './GridLine'\nimport { Line } from '../types'\n\nexport const GridLines = memo(({ lines }: { lines: Line[] }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const transition = useTransition<Line, Record<'opacity' | 'x1' | 'x2' | 'y1' | 'y2', number>>(\n        lines,\n        {\n            keys: line => line.key,\n            initial: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            from: line => ({\n                opacity: 0,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            enter: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            update: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            leave: {\n                opacity: 0,\n            },\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n\n    return (\n        <g>\n            {transition((animatedProps, line) => (\n                <GridLine {...line} key={line.key} animatedProps={animatedProps} />\n            ))}\n        </g>\n    )\n})\n","import React, { useMemo, memo } from 'react'\nimport { GridLines } from './GridLines'\nimport { computeGridLines } from '../compute'\nimport { AnyScale, AxisValue } from '../types'\n\nexport const Grid = memo(\n    <X extends AxisValue, Y extends AxisValue>({\n        width,\n        height,\n        xScale,\n        yScale,\n        xValues,\n        yValues,\n    }: {\n        width: number\n        height: number\n        xScale?: AnyScale\n        xValues?: number | X[]\n        yScale?: AnyScale\n        yValues?: number | Y[]\n    }) => {\n        const xLines = useMemo(() => {\n            if (!xScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: xScale,\n                axis: 'x',\n                values: xValues,\n            })\n        }, [xScale, xValues, width, height])\n\n        const yLines = useMemo(() => {\n            if (!yScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: yScale,\n                axis: 'y',\n                values: yValues,\n            })\n        }, [height, width, yScale, yValues])\n\n        return (\n            <>\n                {xLines && <GridLines lines={xLines} />}\n                {yLines && <GridLines lines={yLines} />}\n            </>\n        )\n    }\n)\n","import { degreesToRadians, CompleteTheme } from '@nivo/core'\nimport { computeCartesianTicks, getFormatter, computeGridLines } from './compute'\nimport { positions } from './props'\nimport {\n    AxisValue,\n    TicksSpec,\n    AnyScale,\n    AxisLegendPosition,\n    CanvasAxisProp,\n    ValueFormatter,\n} from './types'\n\nexport const renderAxisToCanvas = <Value extends AxisValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        axis,\n        scale,\n        x = 0,\n        y = 0,\n        length,\n\n        ticksPosition,\n        tickValues,\n        tickSize = 5,\n        tickPadding = 5,\n        tickRotation = 0,\n        format: _format,\n\n        legend,\n        legendPosition = 'end',\n        legendOffset = 0,\n\n        theme,\n    }: {\n        axis: 'x' | 'y'\n        scale: AnyScale\n        x?: number\n        y?: number\n        length: number\n        ticksPosition: 'before' | 'after'\n        tickValues?: TicksSpec<Value>\n        tickSize?: number\n        tickPadding?: number\n        tickRotation?: number\n        format?: string | ValueFormatter<Value>\n        legend?: string\n        legendPosition?: AxisLegendPosition\n        legendOffset?: number\n        theme: CompleteTheme\n    }\n) => {\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        engine: 'canvas',\n    })\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.textAlign = textAlign\n    ctx.textBaseline = textBaseline\n    ctx.font = `${theme.axis.ticks.text.fontSize}px ${theme.axis.ticks.text.fontFamily}`\n\n    if ((theme.axis.domain.line.strokeWidth ?? 0) > 0) {\n        ctx.lineWidth = Number(theme.axis.domain.line.strokeWidth)\n        ctx.lineCap = 'square'\n\n        if (theme.axis.domain.line.stroke) {\n            ctx.strokeStyle = theme.axis.domain.line.stroke\n        }\n\n        ctx.beginPath()\n        ctx.moveTo(0, 0)\n        ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length)\n        ctx.stroke()\n    }\n\n    const format = typeof _format === 'function' ? _format : (value: unknown) => `${value}`\n\n    ticks.forEach(tick => {\n        if ((theme.axis.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            ctx.lineCap = 'square'\n\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x, tick.y)\n            ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY)\n            ctx.stroke()\n        }\n\n        const value = format(tick.value)\n\n        ctx.save()\n        ctx.translate(tick.x + tick.textX, tick.y + tick.textY)\n        ctx.rotate(degreesToRadians(tickRotation))\n\n        if (theme.axis.ticks.text.fill) {\n            ctx.fillStyle = theme.axis.ticks.text.fill\n        }\n\n        ctx.fillText(String(value), 0, 0)\n        ctx.restore()\n    })\n\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAlign: CanvasTextAlign = 'center'\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n                legendX = length\n            }\n        }\n\n        ctx.translate(legendX, legendY)\n        ctx.rotate(degreesToRadians(legendRotation))\n        ctx.font = `${\n            theme.axis.legend.text.fontWeight ? `${theme.axis.legend.text.fontWeight} ` : ''\n        }${theme.axis.legend.text.fontSize}px ${theme.axis.legend.text.fontFamily}`\n\n        if (theme.axis.legend.text.fill) {\n            ctx.fillStyle = theme.axis.legend.text.fill\n        }\n\n        ctx.textAlign = textAlign\n        ctx.textBaseline = 'middle'\n        ctx.fillText(legend, 0, 0)\n    }\n\n    ctx.restore()\n}\n\nexport const renderAxesToCanvas = <X extends AxisValue, Y extends AxisValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        xScale,\n        yScale,\n        width,\n        height,\n\n        top,\n        right,\n        bottom,\n        left,\n\n        theme,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: CanvasAxisProp<X>\n        right?: CanvasAxisProp<Y>\n        bottom?: CanvasAxisProp<X>\n        left?: CanvasAxisProp<Y>\n        theme: CompleteTheme\n    }\n) => {\n    const axes = { top, right, bottom, left }\n\n    positions.forEach(position => {\n        const axis = axes[position] as typeof position extends 'bottom' | 'top'\n            ? CanvasAxisProp<X> | undefined\n            : CanvasAxisProp<Y> | undefined\n\n        if (!axis) return null\n\n        const isXAxis = position === 'top' || position === 'bottom'\n        const ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after'\n        const scale = isXAxis ? xScale : yScale\n        const format = getFormatter(axis.format, scale)\n\n        renderAxisToCanvas(ctx, {\n            ...axis,\n            axis: isXAxis ? 'x' : 'y',\n            x: position === 'right' ? width : 0,\n            y: position === 'bottom' ? height : 0,\n            scale,\n            format,\n            length: isXAxis ? width : height,\n            ticksPosition,\n            theme,\n        })\n    })\n}\n\nexport const renderGridLinesToCanvas = <Value extends AxisValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        width,\n        height,\n        scale,\n        axis,\n        values,\n    }: {\n        width: number\n        height: number\n        scale: AnyScale\n        axis: 'x' | 'y'\n        values?: TicksSpec<Value>\n    }\n) => {\n    const lines = computeGridLines({ width, height, scale, axis, values })\n\n    lines.forEach(line => {\n        ctx.beginPath()\n        ctx.moveTo(line.x1, line.y1)\n        ctx.lineTo(line.x2, line.y2)\n        ctx.stroke()\n    })\n}\n"]},"metadata":{},"sourceType":"module"}