{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { scaleLinear, scaleLog, scaleSymlog, scalePoint, scaleUtc, scaleTime } from 'd3-scale';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\n\nvar linearScale = function linearScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse,\n      _ref$clamp = _ref.clamp,\n      clamp = _ref$clamp === void 0 ? false : _ref$clamp,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = stacked === true ? values.minStacked : values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = stacked === true ? values.maxStacked : values.max;\n  }\n\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]);\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  if (nice === true) scale.nice();else if (typeof nice === 'number') scale.nice(nice);\n  scale.type = 'linear';\n  scale.stacked = stacked;\n  scale.clamp(clamp);\n  return scale;\n};\n\nvar linearScalePropTypes = {\n  type: PropTypes.oneOf(['linear']).isRequired,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  stacked: PropTypes.bool,\n  reverse: PropTypes.bool,\n  clamp: PropTypes.bool,\n  nice: PropTypes.oneOfType([PropTypes.number, PropTypes.bool])\n};\n\nvar logScale = function logScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var hasZero = values.all.some(function (v) {\n    return v === 0;\n  });\n  var sign;\n  var hasMixedSign = false;\n  values.all.filter(function (v) {\n    return v != null;\n  }).forEach(function (v) {\n    if (hasMixedSign === true) return;\n\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n\n  if (hasZero || hasMixedSign) {\n    throw new Error([\"a log scale domain must be strictly-positive or strictly-negative,\", \"and must not include or cross zero.\"].join('\\n'));\n  }\n\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  scale.type = 'log';\n  return scale;\n};\n\nvar logScalePropTypes = {\n  type: PropTypes.oneOf(['log']).isRequired,\n  base: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar symlogScale = function symlogScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$constant = _ref.constant,\n      constant = _ref$constant === void 0 ? 1 : _ref$constant,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n\n  var scale = scaleSymlog().domain([minValue, maxValue]).constant(constant).rangeRound(axis === 'x' ? [0, size] : [size, 0]).nice();\n  scale.type = 'symlog';\n  return scale;\n};\n\nvar symLogScalePropTypes = {\n  type: PropTypes.oneOf(['symlog']).isRequired,\n  constant: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar pointScale = function pointScale(_ref, xy, width, height) {\n  var axis = _ref.axis;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var scale = scalePoint().range([0, size]).domain(values.all);\n  scale.type = 'point';\n  return scale;\n};\n\nvar pointScalePropTypes = {\n  type: PropTypes.oneOf(['point']).isRequired\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _precisionCutOffsByTy;\n\nvar TIME_PRECISION_MILLISECOND = 'millisecond';\nvar TIME_PRECISION_SECOND = 'second';\nvar TIME_PRECISION_MINUTE = 'minute';\nvar TIME_PRECISION_HOUR = 'hour';\nvar TIME_PRECISION_DAY = 'day';\nvar TIME_PRECISION_MONTH = 'month';\nvar TIME_PRECISION_YEAR = 'year';\nvar timePrecisions = [TIME_PRECISION_MILLISECOND, TIME_PRECISION_SECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_HOUR, TIME_PRECISION_DAY, TIME_PRECISION_MONTH, TIME_PRECISION_YEAR];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = (_precisionCutOffsByTy = {}, _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MILLISECOND, []), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_SECOND, precisionCutOffs.slice(0, 1)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MINUTE, precisionCutOffs.slice(0, 2)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_HOUR, precisionCutOffs.slice(0, 3)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_DAY, precisionCutOffs.slice(0, 4)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MONTH, precisionCutOffs.slice(0, 5)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_YEAR, precisionCutOffs.slice(0, 6)), _precisionCutOffsByTy);\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  if (format === 'native') return function (v) {\n    return precisionFn(v);\n  };\n  var parseTime = useUTC ? utcParse(format) : timeParse(format);\n  return function (v) {\n    return precisionFn(parseTime(v));\n  };\n};\n\nvar timeScale = function timeScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? TIME_PRECISION_MILLISECOND : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC,\n      _ref$nice = _ref.nice,\n      nice = _ref$nice === void 0 ? false : _ref$nice;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  } else if (format !== 'native') {\n    minValue = normalize(min);\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  } else if (format !== 'native') {\n    maxValue = normalize(max);\n  }\n\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.domain([minValue, maxValue]).range([0, size]);\n  if (nice === true) scale.nice();else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice);\n  scale.type = 'time';\n  scale.useUTC = useUTC;\n  return scale;\n};\n\nvar timeScalePropTypes = {\n  type: PropTypes.oneOf(['time']).isRequired,\n  format: PropTypes.string,\n  precision: PropTypes.oneOf(timePrecisions),\n  nice: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.object])\n};\nvar bandScalePropTypes = {\n  type: PropTypes.oneOf(['band']).isRequired,\n  round: PropTypes.bool\n};\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _objectSpread2(_objectSpread2({}, serie), {}, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _objectSpread2({}, d)\n        };\n      })\n    });\n  });\n\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n\n  if (xScaleSpec.stacked === true) {\n    stackX(yScaleSpec.type, xy, series);\n  }\n\n  if (yScaleSpec.stacked === true) {\n    stackY(xScaleSpec.type, xy, series);\n  }\n\n  var xScale = computeScale(_objectSpread2(_objectSpread2({}, xScaleSpec), {}, {\n    axis: 'x'\n  }), xy, width, height);\n  var yScale = computeScale(_objectSpread2(_objectSpread2({}, yScaleSpec), {}, {\n    axis: 'y'\n  }), xy, width, height);\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      d.position = {\n        x: xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : xScale(d.data.x),\n        y: yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : yScale(d.data.y)\n      };\n    });\n  });\n  return _objectSpread2(_objectSpread2({}, xy), {}, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar computeScale = function computeScale(spec, xy, width, height) {\n  if (spec.type === 'linear') return linearScale(spec, xy, width, height);else if (spec.type === 'point') return pointScale(spec, xy, width, height);else if (spec.type === 'time') return timeScale(spec, xy, width, height);else if (spec.type === 'log') return logScale(spec, xy, width, height);else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height);\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)));\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseTime(getValue(d)));\n      });\n    });\n  }\n\n  var all = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      all.push(getValue(d));\n    });\n  });\n  var min, max;\n\n  if (scaleSpec.type === 'linear') {\n    all = uniq(all);\n    all = sortBy(all, function (v) {\n      return v;\n    });\n    min = Math.min.apply(Math, _toConsumableArray(all));\n    max = Math.max.apply(Math, _toConsumableArray(all));\n  } else if (scaleSpec.type === 'time') {\n    all = uniqBy(all, function (v) {\n      return v.getTime();\n    });\n    all = all.slice(0).sort(function (a, b) {\n      return b - a;\n    }).reverse();\n    min = all[0];\n    max = last(all);\n  } else {\n    all = uniq(all);\n    min = all[0];\n    max = last(all);\n  }\n\n  return {\n    all: all,\n    min: min,\n    max: max\n  };\n};\n\nvar stackAxis = function stackAxis(axis, otherType, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[\"\".concat(axis, \"Stacked\")] = stackValue;\n      }\n\n      stack.push(stackValue);\n      all.push(stackValue);\n    });\n  });\n  all = all.filter(function (v) {\n    return v !== null;\n  });\n  xy[axis].minStacked = Math.min.apply(Math, _toConsumableArray(all));\n  xy[axis].maxStacked = Math.max.apply(Math, _toConsumableArray(all));\n};\n\nvar stackX = function stackX(xy, otherType, series) {\n  return stackAxis('x', xy, otherType, series);\n};\n\nvar stackY = function stackY(xy, otherType, series) {\n  return stackAxis('y', xy, otherType, series);\n};\n\nvar computeAxisSlices = function computeAxisSlices(axis, data) {\n  var otherAxis = getOtherAxis(axis);\n  return data[otherAxis].all.map(function (v) {\n    var _slice;\n\n    var slice = (_slice = {\n      id: v\n    }, _defineProperty(_slice, otherAxis, data[\"\".concat(otherAxis, \"Scale\")](v)), _defineProperty(_slice, \"data\", []), _slice);\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    data.series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n\n      if (datum !== undefined) {\n        slice.data.push(_objectSpread2(_objectSpread2({}, datum), {}, {\n          serie: serie\n        }));\n      }\n    });\n    slice.data.reverse();\n    return slice;\n  });\n};\n\nvar computeXSlices = function computeXSlices(data) {\n  return computeAxisSlices('x', data);\n};\n\nvar computeYSlices = function computeYSlices(data) {\n  return computeAxisSlices('y', data);\n};\n\nvar scalePropType = PropTypes.oneOfType([PropTypes.shape(linearScalePropTypes), PropTypes.shape(pointScalePropTypes), PropTypes.shape(timeScalePropTypes), PropTypes.shape(logScalePropTypes), PropTypes.shape(symLogScalePropTypes), PropTypes.shape(bandScalePropTypes)]);\nexport { TIME_PRECISION_DAY, TIME_PRECISION_HOUR, TIME_PRECISION_MILLISECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_MONTH, TIME_PRECISION_SECOND, TIME_PRECISION_YEAR, bandScalePropTypes, compareDateValues, compareValues, computeAxisSlices, computeScale, computeXSlices, computeXYScalesForSeries, computeYSlices, createDateNormalizer, createPrecisionMethod, generateSeriesAxis, generateSeriesXY, getOtherAxis, linearScale, linearScalePropTypes, logScale, logScalePropTypes, pointScale, pointScalePropTypes, precisionCutOffs, precisionCutOffsByType, scalePropType, stackAxis, stackX, stackY, symLogScalePropTypes, symlogScale, timePrecisions, timeScale, timeScalePropTypes };","map":{"version":3,"mappings":";;;;;;;;;IAWaA,WAAW,GAAG,SAAdA,WAAc,OAEvBC,EAFuB,EAGvBC,KAHuB,EAIvBC,MAJuB,EAKtB;EAAA,IAJCC,IAID,QAJCA,IAID;EAAA,oBAJOC,GAIP;EAAA,IAJOA,GAIP,yBAJa,CAIb;EAAA,oBAJgBC,GAIhB;EAAA,IAJgBA,GAIhB,yBAJsB,MAItB;EAAA,wBAJ8BC,OAI9B;EAAA,IAJ8BA,OAI9B,6BAJwC,KAIxC;EAAA,wBAJ+CC,OAI/C;EAAA,IAJ+CA,OAI/C,6BAJyD,KAIzD;EAAA,sBAJgEC,KAIhE;EAAA,IAJgEA,KAIhE,2BAJwE,KAIxE;EAAA,qBAJ+EC,IAI/E;EAAA,IAJ+EA,IAI/E,0BAJsF,KAItF;EACD,IAAMC,MAAM,GAAGV,EAAE,CAACG,IAAD,CAAjB;EACA,IAAMQ,IAAI,GAAGR,IAAI,KAAK,GAATA,GAAeF,KAAfE,GAAuBD,MAApC;EAEA,IAAIU,QAAQ,GAAGR,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBQ,QAAQ,GAAGN,OAAO,KAAK,IAAZA,GAAmBI,MAAM,CAACG,UAA1BP,GAAuCI,MAAM,CAACN,GAAzDQ;EACH;;EACD,IAAIE,QAAQ,GAAGT,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBS,QAAQ,GAAGR,OAAO,KAAK,IAAZA,GAAmBI,MAAM,CAACK,UAA1BT,GAAuCI,MAAM,CAACL,GAAzDS;EACH;;EAED,IAAME,KAAK,GAAGC,WAAW,GAAGC,UAAdD,CAAyBd,IAAI,KAAK,GAATA,GAAe,CAAC,CAAD,EAAIQ,IAAJ,CAAfR,GAA2B,CAACQ,IAAD,EAAO,CAAP,CAApDM,CAAd;EAEA,IAAIV,OAAO,KAAK,IAAhB,EAAsBS,KAAK,CAACG,MAANH,CAAa,CAACF,QAAD,EAAWF,QAAX,CAAbI,EAAtB,KACKA,KAAK,CAACG,MAANH,CAAa,CAACJ,QAAD,EAAWE,QAAX,CAAbE;EAEL,IAAIP,IAAI,KAAK,IAAb,EAAmBO,KAAK,CAACP,IAANO,GAAnB,KACK,IAAI,OAAOP,IAAP,KAAgB,QAApB,EAA8BO,KAAK,CAACP,IAANO,CAAWP,IAAXO;EAEnCA,KAAK,CAACI,IAANJ,GAAa,QAAbA;EACAA,KAAK,CAACV,OAANU,GAAgBV,OAAhBU;EACAA,KAAK,CAACR,KAANQ,CAAYR,KAAZQ;EAEA,OAAOA,KAAP;AACH;;IAEYK,oBAAoB,GAAG;EAChCD,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,QAAD,CAAhBA,EAA4BE,UADF;EAEhCpB,GAAG,EAAEkB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ,CAF2B;EAGhCjB,GAAG,EAAEiB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ,CAH2B;EAIhChB,OAAO,EAAEgB,SAAS,CAACK,IAJa;EAKhCpB,OAAO,EAAEe,SAAS,CAACK,IALa;EAMhCnB,KAAK,EAAEc,SAAS,CAACK,IANe;EAOhClB,IAAI,EAAEa,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACI,MAAX,EAAmBJ,SAAS,CAACK,IAA7B,CAApBL;AAP0B;;ICjCvBM,QAAQ,GAAG,SAAXA,QAAW,OAAkD5B,EAAlD,EAAsDC,KAAtD,EAA6DC,MAA7D,EAAwE;EAAA,IAArEC,IAAqE,QAArEA,IAAqE;EAAA,qBAA/D0B,IAA+D;EAAA,IAA/DA,IAA+D,0BAAxD,EAAwD;EAAA,oBAApDzB,GAAoD;EAAA,IAApDA,GAAoD,yBAA9C,MAA8C;EAAA,oBAAtCC,GAAsC;EAAA,IAAtCA,GAAsC,yBAAhC,MAAgC;EAC5F,IAAMK,MAAM,GAAGV,EAAE,CAACG,IAAD,CAAjB;EACA,IAAMQ,IAAI,GAAGR,IAAI,KAAK,GAATA,GAAeF,KAAfE,GAAuBD,MAApC;EAEA,IAAM4B,OAAO,GAAGpB,MAAM,CAACqB,GAAPrB,CAAWsB,IAAXtB,CAAgB,aAAC;IAAA,OAAIuB,CAAC,KAAK,CAAV;EAAjB,EAAhB;EACA,IAAIC,IAAJ;EACA,IAAIC,YAAY,GAAG,KAAnB;EACAzB,MAAM,CAACqB,GAAPrB,CACK0B,MADL1B,CACY,aAAC;IAAA,OAAIuB,CAAC,IAAI,IAAT;EADb,GAEKI,OAFL3B,CAEa,aAAK;IACV,IAAIyB,YAAY,KAAK,IAArB,EAA2B;;IAC3B,IAAID,IAAI,KAAKI,SAAb,EAAwB;MACpBJ,IAAI,GAAGK,IAAI,CAACL,IAALK,CAAUN,CAAVM,CAAPL;IADJ,OAEO,IAAIK,IAAI,CAACL,IAALK,CAAUN,CAAVM,MAAiBL,IAArB,EAA2B;MAC9BC,YAAY,GAAG,IAAfA;IACH;EART;;EAWA,IAAIL,OAAO,IAAIK,YAAf,EAA6B;IACzB,MAAM,IAAIK,KAAJ,CACF,8GAGEC,IAHF,CAGO,IAHP,CADE,CAAN;EAMH;;EAED,IAAI7B,QAAQ,GAAGR,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBQ,QAAQ,GAAGF,MAAM,CAACN,GAAlBQ;EACH;;EACD,IAAIE,QAAQ,GAAGT,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBS,QAAQ,GAAGJ,MAAM,CAACL,GAAlBS;EACH;;EAED,IAAME,KAAK,GAAG0B,QAAQ,GACjBvB,MADSuB,CACF,CAAC9B,QAAD,EAAWE,QAAX,CADE4B,EAETxB,UAFSwB,CAEEvC,IAAI,KAAK,GAATA,GAAe,CAAC,CAAD,EAAIQ,IAAJ,CAAfR,GAA2B,CAACQ,IAAD,EAAO,CAAP,CAF7B+B,EAGTb,IAHSa,CAGJb,IAHIa,EAITjC,IAJSiC,EAAd;EAMA1B,KAAK,CAACI,IAANJ,GAAa,KAAbA;EAEA,OAAOA,KAAP;AACH;;IAEY2B,iBAAiB,GAAG;EAC7BvB,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,KAAD,CAAhBA,EAAyBE,UADF;EAE7BK,IAAI,EAAEP,SAAS,CAACI,MAFa;EAG7BtB,GAAG,EAAEkB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ,CAHwB;EAI7BjB,GAAG,EAAEiB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ;AAJwB;;IC/CpBsB,WAAW,GAAG,SAAdA,WAAc,OAEvB5C,EAFuB,EAGvBC,KAHuB,EAIvBC,MAJuB,EAKtB;EAAA,IAJCC,IAID,QAJCA,IAID;EAAA,yBAJO0C,QAIP;EAAA,IAJOA,QAIP,8BAJkB,CAIlB;EAAA,oBAJqBzC,GAIrB;EAAA,IAJqBA,GAIrB,yBAJ2B,MAI3B;EAAA,oBAJmCC,GAInC;EAAA,IAJmCA,GAInC,yBAJyC,MAIzC;EACD,IAAMK,MAAM,GAAGV,EAAE,CAACG,IAAD,CAAjB;EACA,IAAMQ,IAAI,GAAGR,IAAI,KAAK,GAATA,GAAeF,KAAfE,GAAuBD,MAApC;EAEA,IAAIU,QAAQ,GAAGR,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBQ,QAAQ,GAAGF,MAAM,CAACN,GAAlBQ;EACH;;EAED,IAAIE,QAAQ,GAAGT,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBS,QAAQ,GAAGJ,MAAM,CAACL,GAAlBS;EACH;;EAED,IAAME,KAAK,GAAG8B,WAAW,GACpB3B,MADS2B,CACF,CAAClC,QAAD,EAAWE,QAAX,CADEgC,EAETD,QAFSC,CAEAD,QAFAC,EAGT5B,UAHS4B,CAGE3C,IAAI,KAAK,GAATA,GAAe,CAAC,CAAD,EAAIQ,IAAJ,CAAfR,GAA2B,CAACQ,IAAD,EAAO,CAAP,CAH7BmC,EAITrC,IAJSqC,EAAd;EAMA9B,KAAK,CAACI,IAANJ,GAAa,QAAbA;EAEA,OAAOA,KAAP;AACH;;IAEY+B,oBAAoB,GAAG;EAChC3B,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,QAAD,CAAhBA,EAA4BE,UADF;EAEhCqB,QAAQ,EAAEvB,SAAS,CAACI,MAFY;EAGhCtB,GAAG,EAAEkB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ,CAH2B;EAIhCjB,GAAG,EAAEiB,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,CAAD,EAA4BA,SAAS,CAACI,MAAtC,CAApBJ;AAJ2B;;IC9BvB0B,UAAU,GAAG,SAAbA,UAAa,OAAWhD,EAAX,EAAeC,KAAf,EAAsBC,MAAtB,EAAiC;EAAA,IAA9BC,IAA8B,QAA9BA,IAA8B;EACvD,IAAMO,MAAM,GAAGV,EAAE,CAACG,IAAD,CAAjB;EACA,IAAMQ,IAAI,GAAGR,IAAI,KAAK,GAATA,GAAeF,KAAfE,GAAuBD,MAApC;EAEA,IAAMc,KAAK,GAAGiC,UAAU,GAAGC,KAAbD,CAAmB,CAAC,CAAD,EAAItC,IAAJ,CAAnBsC,EAA8B9B,MAA9B8B,CAAqCvC,MAAM,CAACqB,GAA5CkB,CAAd;EAEAjC,KAAK,CAACI,IAANJ,GAAa,OAAbA;EAEA,OAAOA,KAAP;AACH;;IAEYmC,mBAAmB,GAAG;EAC/B/B,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,OAAD,CAAhBA,EAA2BE;AADF;;ACtBpB,SAAS4B,eAAT,CAAyBC,GAAzB,EAA8BC,GAA9B,EAAmCC,KAAnC,EAA0C;EACvD,IAAID,GAAG,IAAID,GAAX,EAAgB;IACdG,MAAM,CAACC,cAAP,CAAsBJ,GAAtB,EAA2BC,GAA3B,EAAgC;MAC9BC,KAAK,EAAEA,KADuB;MAE9BG,UAAU,EAAE,IAFkB;MAG9BC,YAAY,EAAE,IAHgB;MAI9BC,QAAQ,EAAE;IAJoB,CAAhC;EAMD,CAPD,MAOO;IACLP,GAAG,CAACC,GAAD,CAAH,GAAWC,KAAX;EACD;;EAED,OAAOF,GAAP;AACF;;;;ICHaQ,0BAA0B,GAAG;IAC7BC,qBAAqB,GAAG;IACxBC,qBAAqB,GAAG;IACxBC,mBAAmB,GAAG;IACtBC,kBAAkB,GAAG;IACrBC,oBAAoB,GAAG;IACvBC,mBAAmB,GAAG;IAEtBC,cAAc,GAAG,CAC1BP,0BAD0B,EAE1BC,qBAF0B,EAG1BC,qBAH0B,EAI1BC,mBAJ0B,EAK1BC,kBAL0B,EAM1BC,oBAN0B,EAO1BC,mBAP0B;IAUjBE,gBAAgB,GAAG,CAC5B,gBAAI;EAAA,OAAIC,IAAI,CAACC,eAALD,CAAqB,CAArBA,CAAJ;AADwB,GAE5B,gBAAI;EAAA,OAAIA,IAAI,CAACE,UAALF,CAAgB,CAAhBA,CAAJ;AAFwB,GAG5B,gBAAI;EAAA,OAAIA,IAAI,CAACG,UAALH,CAAgB,CAAhBA,CAAJ;AAHwB,GAI5B,gBAAI;EAAA,OAAIA,IAAI,CAACI,QAALJ,CAAc,CAAdA,CAAJ;AAJwB,GAK5B,gBAAI;EAAA,OAAIA,IAAI,CAACK,OAALL,CAAa,CAAbA,CAAJ;AALwB,GAM5B,gBAAI;EAAA,OAAIA,IAAI,CAACM,QAALN,CAAc,CAAdA,CAAJ;AANwB;IASnBO,sBAAsB,uEAC9BhB,0BAD8B,EACD,EADC,0CAE9BC,qBAF8B,EAENO,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CAFM,0CAG9BN,qBAH8B,EAGNM,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CAHM,0CAI9BL,mBAJ8B,EAIRK,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CAJQ,0CAK9BJ,kBAL8B,EAKTI,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CALS,0CAM9BH,oBAN8B,EAMPG,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CANO,0CAO9BF,mBAP8B,EAORE,gBAAgB,CAACS,KAAjBT,CAAuB,CAAvBA,EAA0B,CAA1BA,CAPQ;;IAUtBU,qBAAqB,GAAG,SAAxBA,qBAAwB,YAAS;EAAA,OAAI,gBAAQ;IACtDF,sBAAsB,CAACG,SAAD,CAAtBH,CAAkCxC,OAAlCwC,CAA0C,kBAAU;MAChDI,MAAM,CAACX,IAAD,CAANW;IADJ;IAGA,OAAOX,IAAP;EAJ0C;AAAA;;IAOjCY,oBAAoB,GAAG,SAAvBA,oBAAuB,OAI9B;EAAA,uBAHFC,MAGE;EAAA,IAHFA,MAGE,4BAHO,QAGP;EAAA,0BAFFH,SAEE;EAAA,IAFFA,SAEE,+BAFU,aAEV;EAAA,uBADFI,MACE;EAAA,IADFA,MACE,4BADO,IACP;EACF,IAAMC,WAAW,GAAGN,qBAAqB,CAACC,SAAD,CAAzC;EACA,IAAIG,MAAM,KAAK,QAAf,EAAyB,OAAO,aAAC;IAAA,OAAIE,WAAW,CAACpD,CAAD,CAAf;EAAR;EAEzB,IAAMqD,SAAS,GAAGF,MAAM,GAAGG,QAAQ,CAACJ,MAAD,CAAX,GAAsBK,SAAS,CAACL,MAAD,CAAvD;EACA,OAAO,aAAC;IAAA,OAAIE,WAAW,CAACC,SAAS,CAACrD,CAAD,CAAV,CAAf;EAAR;AACH;;ICpDYwD,SAAS,GAAG,SAAZA,SAAY,OAUrBzF,EAVqB,EAWrBC,KAXqB,EAYrBC,MAZqB,EAapB;EAAA,IAXGC,IAWH,QAXGA,IAWH;EAAA,uBAVGgF,MAUH;EAAA,IAVGA,MAUH,4BAVY,QAUZ;EAAA,0BATGH,SASH;EAAA,IATGA,SASH,+BATenB,0BASf;EAAA,oBARGzD,GAQH;EAAA,IARGA,GAQH,yBARS,MAQT;EAAA,oBAPGC,GAOH;EAAA,IAPGA,GAOH,yBAPS,MAOT;EAAA,uBANG+E,MAMH;EAAA,IANGA,MAMH,4BANY,IAMZ;EAAA,qBALG3E,IAKH;EAAA,IALGA,IAKH,0BALU,KAKV;EACD,IAAMC,MAAM,GAAGV,EAAE,CAACG,IAAD,CAAjB;EACA,IAAMQ,IAAI,GAAGR,IAAI,KAAK,GAATA,GAAeF,KAAfE,GAAuBD,MAApC;EAEA,IAAMwF,SAAS,GAAGR,oBAAoB,CAAC;IAAEC,MAAM,EAANA,MAAF;IAAUH,SAAS,EAATA,SAAV;IAAqBI,MAAM,EAANA;EAArB,CAAD,CAAtC;EAEA,IAAIxE,QAAQ,GAAGR,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBQ,QAAQ,GAAGF,MAAM,CAACN,GAAlBQ;EADJ,OAEO,IAAIuE,MAAM,KAAK,QAAf,EAAyB;IAC5BvE,QAAQ,GAAG8E,SAAS,CAACtF,GAAD,CAApBQ;EACH;;EAED,IAAIE,QAAQ,GAAGT,GAAf;;EACA,IAAIA,GAAG,KAAK,MAAZ,EAAoB;IAChBS,QAAQ,GAAGJ,MAAM,CAACL,GAAlBS;EADJ,OAEO,IAAIqE,MAAM,KAAK,QAAf,EAAyB;IAC5BrE,QAAQ,GAAG4E,SAAS,CAACrF,GAAD,CAApBS;EACH;;EAED,IAAME,KAAK,GAAGoE,MAAM,GAAGO,QAAQ,EAAX,GAAgBC,SAAS,EAA7C;EACA5E,KAAK,CAACG,MAANH,CAAa,CAACJ,QAAD,EAAWE,QAAX,CAAbE,EAAmCkC,KAAnClC,CAAyC,CAAC,CAAD,EAAIL,IAAJ,CAAzCK;EACA,IAAIP,IAAI,KAAK,IAAb,EAAmBO,KAAK,CAACP,IAANO,GAAnB,KACK,IAAI,OAAOP,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,QAAhD,EAA0DO,KAAK,CAACP,IAANO,CAAWP,IAAXO;EAE/DA,KAAK,CAACI,IAANJ,GAAa,MAAbA;EACAA,KAAK,CAACoE,MAANpE,GAAeoE,MAAfpE;EAEA,OAAOA,KAAP;AACH;;IAEY6E,kBAAkB,GAAG;EAC9BzE,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,EAA0BE,UADF;EAE9B2D,MAAM,EAAE7D,SAAS,CAACwE,MAFY;EAG9Bd,SAAS,EAAE1D,SAAS,CAACC,KAAVD,CAAgB8C,cAAhB9C,CAHmB;EAI9Bb,IAAI,EAAEa,SAAS,CAACG,SAAVH,CAAoB,CAACA,SAAS,CAACK,IAAX,EAAiBL,SAAS,CAACI,MAA3B,EAAmCJ,SAAS,CAACyE,MAA7C,CAApBzE;AAJwB;IC9CrB0E,kBAAkB,GAAG;EAC9B5E,IAAI,EAAEE,SAAS,CAACC,KAAVD,CAAgB,CAAC,MAAD,CAAhBA,EAA0BE,UADF;EAE9ByE,KAAK,EAAE3E,SAAS,CAACK;AAFa;;ACVnB,SAASuE,iBAAT,CAA2BC,GAA3B,EAAgCC,GAAhC,EAAqC;EAClD,IAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAACE,MAA7B,EAAqCD,GAAG,GAAGD,GAAG,CAACE,MAAV;;EAErC,KAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG,IAAIC,KAAJ,CAAUJ,GAAV,CAAvB,EAAuCE,CAAC,GAAGF,GAA3C,EAAgDE,CAAC,EAAjD,EAAqD;IACnDC,IAAI,CAACD,CAAD,CAAJ,GAAUH,GAAG,CAACG,CAAD,CAAb;EACD;;EAED,OAAOC,IAAP;AACF;;ACPe,SAASE,kBAAT,CAA4BN,GAA5B,EAAiC;EAC9C,IAAIK,KAAK,CAACE,OAAN,CAAcP,GAAd,CAAJ,EAAwB,OAAOQ,iBAAgB,CAACR,GAAD,CAAvB;AAC1B;;ACHe,SAASS,gBAAT,CAA0BC,IAA1B,EAAgC;EAC7C,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,QAAP,IAAmBvD,MAAM,CAACqD,IAAD,CAA9D,EAAsE,OAAOL,KAAK,CAACQ,IAAN,CAAWH,IAAX,CAAP;AACxE;;ACDe,SAASI,2BAAT,CAAqCC,CAArC,EAAwCC,MAAxC,EAAgD;EAC7D,IAAI,CAACD,CAAL,EAAQ;EACR,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOP,iBAAgB,CAACO,CAAD,EAAIC,MAAJ,CAAvB;EAC3B,IAAIC,CAAC,GAAG5D,MAAM,CAAC6D,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,EAAkCpC,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;EACA,IAAIsC,CAAC,KAAK,QAAN,IAAkBF,CAAC,CAACM,WAAxB,EAAqCJ,CAAC,GAAGF,CAAC,CAACM,WAAF,CAAcC,IAAlB;EACrC,IAAIL,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOZ,KAAK,CAACQ,IAAN,CAAWI,CAAX,CAAP;EAChC,IAAIA,CAAC,KAAK,WAAN,IAAqB,2CAA2CM,IAA3C,CAAgDN,CAAhD,CAAzB,EAA6E,OAAOT,iBAAgB,CAACO,CAAD,EAAIC,MAAJ,CAAvB;AAC/E;;ACRe,SAASQ,kBAAT,GAA8B;EAC3C,MAAM,IAAIC,SAAJ,CAAc,sIAAd,CAAN;AACF;;ACEe,SAASC,kBAAT,CAA4B1B,GAA5B,EAAiC;EAC9C,OAAO2B,kBAAiB,CAAC3B,GAAD,CAAjB2B,IAA0BC,gBAAe,CAAC5B,GAAD,CAAzC2B,IAAkDE,2BAA0B,CAAC7B,GAAD,CAA5E2B,IAAqFG,kBAAiB,EAA7G;AACF;;ACJA,SAASC,OAAT,CAAiBnC,MAAjB,EAAyBoC,cAAzB,EAAyC;EACvC,IAAIC,IAAI,GAAG5E,MAAM,CAAC4E,IAAP,CAAYrC,MAAZ,CAAX;;EAEA,IAAIvC,MAAM,CAAC6E,qBAAX,EAAkC;IAChC,IAAIC,OAAO,GAAG9E,MAAM,CAAC6E,qBAAP,CAA6BtC,MAA7B,CAAd;IACA,IAAIoC,cAAJ,EAAoBG,OAAO,GAAGA,OAAO,CAAClG,MAAR,CAAe,UAAUmG,GAAV,EAAe;MAC1D,OAAO/E,MAAM,CAACgF,wBAAP,CAAgCzC,MAAhC,EAAwCwC,GAAxC,EAA6C7E,UAApD;IACD,CAF6B,CAAV;IAGpB0E,IAAI,CAACK,IAAL,CAAUC,KAAV,CAAgBN,IAAhB,EAAsBE,OAAtB;EACD;;EAED,OAAOF,IAAP;AACD;;AAEc,SAASO,cAAT,CAAwBC,MAAxB,EAAgC;EAC7C,KAAK,IAAItC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuC,SAAS,CAACxC,MAA9B,EAAsCC,CAAC,EAAvC,EAA2C;IACzC,IAAIwC,MAAM,GAAGD,SAAS,CAACvC,CAAD,CAAT,IAAgB,IAAhB,GAAuBuC,SAAS,CAACvC,CAAD,CAAhC,GAAsC,EAAnD;;IAEA,IAAIA,CAAC,GAAG,CAAR,EAAW;MACT4B,OAAO,CAAC1E,MAAM,CAACsF,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BzG,OAA9B,CAAsC,UAAUiB,GAAV,EAAe;QACnDG,eAAc,CAACmF,MAAD,EAAStF,GAAT,EAAcwF,MAAM,CAACxF,GAAD,CAApB,CAAdG;MACD,CAFD;IAGD,CAJD,MAIO,IAAID,MAAM,CAACuF,yBAAX,EAAsC;MAC3CvF,MAAM,CAACwF,gBAAP,CAAwBJ,MAAxB,EAAgCpF,MAAM,CAACuF,yBAAP,CAAiCD,MAAjC,CAAhC;IACD,CAFM,MAEA;MACLZ,OAAO,CAAC1E,MAAM,CAACsF,MAAD,CAAP,CAAP,CAAwBzG,OAAxB,CAAgC,UAAUiB,GAAV,EAAe;QAC7CE,MAAM,CAACC,cAAP,CAAsBmF,MAAtB,EAA8BtF,GAA9B,EAAmCE,MAAM,CAACgF,wBAAP,CAAgCM,MAAhC,EAAwCxF,GAAxC,CAAnC;MACD,CAFD;IAGD;EACF;;EAED,OAAOsF,MAAP;AACF;;ICdaK,YAAY,GAAG,SAAfA,YAAe,OAAI;EAAA,OAAK9I,IAAI,KAAK,GAATA,GAAe,GAAfA,GAAqB,GAA1B;AAAA;;IAEnB+I,aAAa,GAAG,SAAhBA,aAAgB,CAACC,CAAD,EAAIC,CAAJ;EAAA,OAAUD,CAAC,KAAKC,CAAhB;AAAA;;IAChBC,iBAAiB,GAAG,SAApBA,iBAAoB,CAACF,CAAD,EAAIC,CAAJ;EAAA,OAAUD,CAAC,CAACG,OAAFH,OAAgBC,CAAC,CAACE,OAAFF,EAA1B;AAAA;;IAEpBG,wBAAwB,GAAG,SAA3BA,wBAA2B,CAACC,OAAD,EAAUC,UAAV,EAAsBC,UAAtB,EAAkCzJ,KAAlC,EAAyCC,MAAzC,EAAoD;EACxF,IAAMyJ,MAAM,GAAGH,OAAO,CAACI,GAARJ,CAAY,iBAAK;IAAA,yCACzBK,KADyB;MAE5BC,IAAI,EAAED,KAAK,CAACC,IAAND,CAAWD,GAAXC,CAAe,aAAC;QAAA,OAAK;UAAEC,IAAI,qBAAOC,CAAP;QAAN,CAAL;MAAhB;IAFsB;EAAjB,EAAf;;EAKA,IAAI/J,EAAE,GAAGgK,gBAAgB,CAACL,MAAD,EAASF,UAAT,EAAqBC,UAArB,CAAzB;;EACA,IAAID,UAAU,CAACnJ,OAAXmJ,KAAuB,IAA3B,EAAiC;IAC7BQ,MAAM,CAACP,UAAU,CAACtI,IAAZ,EAAkBpB,EAAlB,EAAsB2J,MAAtB,CAANM;EACH;;EACD,IAAIP,UAAU,CAACpJ,OAAXoJ,KAAuB,IAA3B,EAAiC;IAC7BQ,MAAM,CAACT,UAAU,CAACrI,IAAZ,EAAkBpB,EAAlB,EAAsB2J,MAAtB,CAANO;EACH;;EAED,IAAMC,MAAM,GAAGC,YAAY,mCAAMX,UAAN;IAAkBtJ,IAAI,EAAE;EAAxB,IAA+BH,EAA/B,EAAmCC,KAAnC,EAA0CC,MAA1C,CAA3B;EACA,IAAMmK,MAAM,GAAGD,YAAY,mCAAMV,UAAN;IAAkBvJ,IAAI,EAAE;EAAxB,IAA+BH,EAA/B,EAAmCC,KAAnC,EAA0CC,MAA1C,CAA3B;EAEAyJ,MAAM,CAACtH,OAAPsH,CAAe,iBAAS;IACpBE,KAAK,CAACC,IAAND,CAAWxH,OAAXwH,CAAmB,aAAK;MACpBE,CAAC,CAACO,QAAFP,GAAa;QACTQ,CAAC,EACGJ,MAAM,CAAC7J,OAAP6J,KAAmB,IAAnBA,GACMJ,CAAC,CAACD,IAAFC,CAAOS,QAAPT,KAAoB,IAApBA,GACI,IADJA,GAEII,MAAM,CAACJ,CAAC,CAACD,IAAFC,CAAOS,QAAR,CAHhBL,GAIMJ,CAAC,CAACD,IAAFC,CAAOQ,CAAPR,KAAa,IAAbA,GACA,IADAA,GAEAI,MAAM,CAACJ,CAAC,CAACD,IAAFC,CAAOQ,CAAR,CARP;QASTE,CAAC,EACGJ,MAAM,CAAC/J,OAAP+J,KAAmB,IAAnBA,GACMN,CAAC,CAACD,IAAFC,CAAOW,QAAPX,KAAoB,IAApBA,GACI,IADJA,GAEIM,MAAM,CAACN,CAAC,CAACD,IAAFC,CAAOW,QAAR,CAHhBL,GAIMN,CAAC,CAACD,IAAFC,CAAOU,CAAPV,KAAa,IAAbA,GACA,IADAA,GAEAM,MAAM,CAACN,CAAC,CAACD,IAAFC,CAAOU,CAAR;MAhBP,CAAbV;IADJ;EADJ;EAuBA,yCACO/J,EADP;IAEI2J,MAAM,EAANA,MAFJ;IAGIQ,MAAM,EAANA,MAHJ;IAIIE,MAAM,EAANA;EAJJ;AAMH;;IAEYD,YAAY,GAAG,SAAfA,YAAe,CAACO,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,EAA6B;EACrD,IAAIyK,IAAI,CAACvJ,IAALuJ,KAAc,QAAlB,EAA4B,OAAO5K,WAAW,CAAC4K,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,CAAlB,CAA5B,KACK,IAAIyK,IAAI,CAACvJ,IAALuJ,KAAc,OAAlB,EAA2B,OAAO3H,UAAU,CAAC2H,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,CAAjB,CAA3B,KACA,IAAIyK,IAAI,CAACvJ,IAALuJ,KAAc,MAAlB,EAA0B,OAAOlF,SAAS,CAACkF,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,CAAhB,CAA1B,KACA,IAAIyK,IAAI,CAACvJ,IAALuJ,KAAc,KAAlB,EAAyB,OAAO/I,QAAQ,CAAC+I,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,CAAf,CAAzB,KACA,IAAIyK,IAAI,CAACvJ,IAALuJ,KAAc,QAAlB,EAA4B,OAAO/H,WAAW,CAAC+H,IAAD,EAAO3K,EAAP,EAAWC,KAAX,EAAkBC,MAAlB,CAAlB;AACpC;;IAEY8J,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACL,MAAD,EAASF,UAAT,EAAqBC,UAArB;EAAA,OAAqC;IACjEa,CAAC,EAAEK,kBAAkB,CAACjB,MAAD,EAAS,GAAT,EAAcF,UAAd,CAD4C;IAEjEgB,CAAC,EAAEG,kBAAkB,CAACjB,MAAD,EAAS,GAAT,EAAcD,UAAd;EAF4C,CAArC;AAAA;;IASnBkB,kBAAkB,GAAG,SAArBA,kBAAqB,CAC9BjB,MAD8B,EAE9BxJ,IAF8B,EAG9B0K,SAH8B,EAU7B;EAAA,+EADG,EACH;EAAA,yBALGC,QAKH;EAAA,IALGA,QAKH,8BALc,aAAC;IAAA,OAAIf,CAAC,CAACD,IAAFC,CAAO5J,IAAP4J,CAAJ;EAKf;EAAA,yBAJGgB,QAIH;EAAA,IAJGA,QAIH,8BAJc,UAAChB,CAAD,EAAI9H,CAAJ,EAAU;IACjB8H,CAAC,CAACD,IAAFC,CAAO5J,IAAP4J,IAAe9H,CAAf8H;EAGP;;EACD,IAAIc,SAAS,CAACzJ,IAAVyJ,KAAmB,QAAvB,EAAiC;IAC7BlB,MAAM,CAACtH,OAAPsH,CAAe,iBAAS;MACpBE,KAAK,CAACC,IAAND,CAAWxH,OAAXwH,CAAmB,aAAK;QACpBkB,QAAQ,CAAChB,CAAD,EAAIe,QAAQ,CAACf,CAAD,CAARe,KAAgB,IAAhBA,GAAuB,IAAvBA,GAA8BE,UAAU,CAACF,QAAQ,CAACf,CAAD,CAAT,CAA5C,CAARgB;MADJ;IADJ;EADJ,OAMO,IAAIF,SAAS,CAACzJ,IAAVyJ,KAAmB,MAAnBA,IAA6BA,SAAS,CAAC1F,MAAV0F,KAAqB,QAAtD,EAAgE;IACnE,IAAMvF,SAAS,GAAGJ,oBAAoB,CAAC2F,SAAD,CAAtC;IACAlB,MAAM,CAACtH,OAAPsH,CAAe,iBAAS;MACpBE,KAAK,CAACC,IAAND,CAAWxH,OAAXwH,CAAmB,aAAK;QACpBkB,QAAQ,CAAChB,CAAD,EAAIe,QAAQ,CAACf,CAAD,CAARe,KAAgB,IAAhBA,GAAuB,IAAvBA,GAA8BxF,SAAS,CAACwF,QAAQ,CAACf,CAAD,CAAT,CAA3C,CAARgB;MADJ;IADJ;EAKH;;EAED,IAAIhJ,GAAG,GAAG,EAAV;EACA4H,MAAM,CAACtH,OAAPsH,CAAe,iBAAS;IACpBE,KAAK,CAACC,IAAND,CAAWxH,OAAXwH,CAAmB,aAAK;MACpB9H,GAAG,CAAC0G,IAAJ1G,CAAS+I,QAAQ,CAACf,CAAD,CAAjBhI;IADJ;EADJ;EAMA,IAAI3B,GAAJ,EAASC,GAAT;;EACA,IAAIwK,SAAS,CAACzJ,IAAVyJ,KAAmB,QAAvB,EAAiC;IAC7B9I,GAAG,GAAGkJ,IAAI,CAAClJ,GAAD,CAAVA;IACAA,GAAG,GAAGmJ,MAAM,CAACnJ,GAAD,EAAM,aAAC;MAAA,OAAIE,CAAJ;IAAP,EAAZF;IACA3B,GAAG,GAAGmC,IAAI,CAACnC,GAALmC,aAAIsF,mBAAQ9F,GAAR,CAAJQ,CAANnC;IACAC,GAAG,GAAGkC,IAAI,CAAClC,GAALkC,aAAIsF,mBAAQ9F,GAAR,CAAJQ,CAANlC;EAJJ,OAKO,IAAIwK,SAAS,CAACzJ,IAAVyJ,KAAmB,MAAvB,EAA+B;IAClC9I,GAAG,GAAGoJ,MAAM,CAACpJ,GAAD,EAAM,aAAC;MAAA,OAAIE,CAAC,CAACqH,OAAFrH,EAAJ;IAAP,EAAZF;IACAA,GAAG,GAAGA,GAAG,CACJ+C,KADC/C,CACK,CADLA,EAEDqJ,IAFCrJ,CAEI,UAACoH,CAAD,EAAIC,CAAJ;MAAA,OAAUA,CAAC,GAAGD,CAAd;IAFJ,GAGD5I,OAHCwB,EAANA;IAIA3B,GAAG,GAAG2B,GAAG,CAAC,CAAD,CAAT3B;IACAC,GAAG,GAAGgL,IAAI,CAACtJ,GAAD,CAAV1B;EAPG,OAQA;IACH0B,GAAG,GAAGkJ,IAAI,CAAClJ,GAAD,CAAVA;IACA3B,GAAG,GAAG2B,GAAG,CAAC,CAAD,CAAT3B;IACAC,GAAG,GAAGgL,IAAI,CAACtJ,GAAD,CAAV1B;EACH;;EAED,OAAO;IAAE0B,GAAG,EAAHA,GAAF;IAAO3B,GAAG,EAAHA,GAAP;IAAYC,GAAG,EAAHA;EAAZ,CAAP;AACH;;IAEYiL,SAAS,GAAG,SAAZA,SAAY,CAACnL,IAAD,EAAOoL,SAAP,EAAkBvL,EAAlB,EAAsB2J,MAAtB,EAAiC;EACtD,IAAM6B,SAAS,GAAGvC,YAAY,CAAC9I,IAAD,CAA9B;EAEA,IAAI4B,GAAG,GAAG,EAAV;EACA/B,EAAE,CAACwL,SAAD,CAAFxL,CAAc+B,GAAd/B,CAAkBqC,OAAlBrC,CAA0B,aAAK;IAC3B,IAAMyL,OAAO,GAAGC,MAAM,CAACzJ,CAAD,CAANyJ,GAAYrC,iBAAZqC,GAAgCxC,aAAhD;IACA,IAAMyC,KAAK,GAAG,EAAd;IACAhC,MAAM,CAACtH,OAAPsH,CAAe,iBAAS;MACpB,IAAMiC,KAAK,GAAG/B,KAAK,CAACC,IAAND,CAAWgC,IAAXhC,CAAgB,aAAC;QAAA,OAAI4B,OAAO,CAAC1B,CAAC,CAACD,IAAFC,CAAOyB,SAAPzB,CAAD,EAAoB9H,CAApB,CAAX;MAAjB,EAAd;MACA,IAAIsB,KAAK,GAAG,IAAZ;MACA,IAAIuI,UAAU,GAAG,IAAjB;;MACA,IAAIF,KAAK,KAAKtJ,SAAd,EAAyB;QACrBiB,KAAK,GAAGqI,KAAK,CAAC9B,IAAN8B,CAAWzL,IAAXyL,CAARrI;;QACA,IAAIA,KAAK,KAAK,IAAd,EAAoB;UAChB,IAAMwI,IAAI,GAAGV,IAAI,CAACM,KAAD,CAAjB;;UACA,IAAII,IAAI,KAAKzJ,SAAb,EAAwB;YACpBwJ,UAAU,GAAGvI,KAAbuI;UADJ,OAEO,IAAIC,IAAI,KAAK,IAAb,EAAmB;YACtBD,UAAU,GAAGC,IAAI,GAAGxI,KAApBuI;UACH;QACJ;;QACDF,KAAK,CAAC9B,IAAN8B,WAAczL,IAAd,gBAA+B2L,UAA/BF;MACH;;MACDD,KAAK,CAAClD,IAANkD,CAAWG,UAAXH;MACA5J,GAAG,CAAC0G,IAAJ1G,CAAS+J,UAAT/J;IAjBJ;EAHJ;EAuBAA,GAAG,GAAGA,GAAG,CAACK,MAAJL,CAAW,aAAC;IAAA,OAAIE,CAAC,KAAK,IAAV;EAAZ,EAANF;EAEA/B,EAAE,CAACG,IAAD,CAAFH,CAASa,UAATb,GAAsBuC,IAAI,CAACnC,GAALmC,aAAIsF,mBAAQ9F,GAAR,CAAJQ,CAAtBvC;EACAA,EAAE,CAACG,IAAD,CAAFH,CAASe,UAATf,GAAsBuC,IAAI,CAAClC,GAALkC,aAAIsF,mBAAQ9F,GAAR,CAAJQ,CAAtBvC;AACH;;IAEYiK,MAAM,GAAG,SAATA,MAAS,CAACjK,EAAD,EAAKuL,SAAL,EAAgB5B,MAAhB;EAAA,OAA2B2B,SAAS,CAAC,GAAD,EAAMtL,EAAN,EAAUuL,SAAV,EAAqB5B,MAArB,CAApC;AAAA;;IACTO,MAAM,GAAG,SAATA,MAAS,CAAClK,EAAD,EAAKuL,SAAL,EAAgB5B,MAAhB;EAAA,OAA2B2B,SAAS,CAAC,GAAD,EAAMtL,EAAN,EAAUuL,SAAV,EAAqB5B,MAArB,CAApC;AAAA;;IAETqC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAC7L,IAAD,EAAO2J,IAAP,EAAgB;EAC7C,IAAM0B,SAAS,GAAGvC,YAAY,CAAC9I,IAAD,CAA9B;EAEA,OAAO2J,IAAI,CAAC0B,SAAD,CAAJ1B,CAAgB/H,GAAhB+H,CAAoBF,GAApBE,CAAwB,aAAK;IAAA;;IAChC,IAAMhF,KAAK;MACPmH,EAAE,EAAEhK;IADG,2BAENuJ,SAFM,EAEM1B,IAAI,WAAI0B,SAAJ,WAAJ1B,CAA0B7H,CAA1B6H,CAFN,mCAGD,EAHC,UAAX;IAKA,IAAM2B,OAAO,GAAGC,MAAM,CAACzJ,CAAD,CAANyJ,GAAYrC,iBAAZqC,GAAgCxC,aAAhD;IACAY,IAAI,CAACH,MAALG,CAAYzH,OAAZyH,CAAoB,iBAAS;MACzB,IAAM8B,KAAK,GAAG/B,KAAK,CAACC,IAAND,CAAWgC,IAAXhC,CAAgB,aAAC;QAAA,OAAI4B,OAAO,CAAC1B,CAAC,CAACD,IAAFC,CAAOyB,SAAPzB,CAAD,EAAoB9H,CAApB,CAAX;MAAjB,EAAd;;MACA,IAAI2J,KAAK,KAAKtJ,SAAd,EAAyB;QACrBwC,KAAK,CAACgF,IAANhF,CAAW2D,IAAX3D,mCACO8G,KADP;UAEI/B,KAAK,EAALA;QAFJ;MAIH;IAPL;IASA/E,KAAK,CAACgF,IAANhF,CAAWvE,OAAXuE;IAEA,OAAOA,KAAP;EAlBG,EAAP;AAoBH;;IAEYoH,cAAc,GAAG,SAAjBA,cAAiB,OAAI;EAAA,OAAIF,iBAAiB,CAAC,GAAD,EAAMlC,IAAN,CAArB;AAAA;;IACrBqC,cAAc,GAAG,SAAjBA,cAAiB,OAAI;EAAA,OAAIH,iBAAiB,CAAC,GAAD,EAAMlC,IAAN,CAArB;AAAA;;ICvLrBsC,aAAa,GAAG9K,SAAS,CAACG,SAAVH,CAAoB,CAC7CA,SAAS,CAAC+K,KAAV/K,CAAgBD,oBAAhBC,CAD6C,EAE7CA,SAAS,CAAC+K,KAAV/K,CAAgB6B,mBAAhB7B,CAF6C,EAG7CA,SAAS,CAAC+K,KAAV/K,CAAgBuE,kBAAhBvE,CAH6C,EAI7CA,SAAS,CAAC+K,KAAV/K,CAAgBqB,iBAAhBrB,CAJ6C,EAK7CA,SAAS,CAAC+K,KAAV/K,CAAgByB,oBAAhBzB,CAL6C,EAM7CA,SAAS,CAAC+K,KAAV/K,CAAgB0E,kBAAhB1E,CAN6C,CAApBA","names":["linearScale","xy","width","height","axis","min","max","stacked","reverse","clamp","nice","values","size","minValue","minStacked","maxValue","maxStacked","scale","scaleLinear","rangeRound","domain","type","linearScalePropTypes","PropTypes","oneOf","isRequired","oneOfType","number","bool","logScale","base","hasZero","all","some","v","sign","hasMixedSign","filter","forEach","undefined","Math","Error","join","scaleLog","logScalePropTypes","symlogScale","constant","scaleSymlog","symLogScalePropTypes","pointScale","scalePoint","range","pointScalePropTypes","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","TIME_PRECISION_MILLISECOND","TIME_PRECISION_SECOND","TIME_PRECISION_MINUTE","TIME_PRECISION_HOUR","TIME_PRECISION_DAY","TIME_PRECISION_MONTH","TIME_PRECISION_YEAR","timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","slice","createPrecisionMethod","precision","cutOff","createDateNormalizer","format","useUTC","precisionFn","parseTime","utcParse","timeParse","timeScale","normalize","scaleUtc","scaleTime","timeScalePropTypes","string","object","bandScalePropTypes","round","_arrayLikeToArray","arr","len","length","i","arr2","Array","_arrayWithoutHoles","isArray","arrayLikeToArray","_iterableToArray","iter","Symbol","iterator","from","_unsupportedIterableToArray","o","minLen","n","prototype","toString","call","constructor","name","test","_nonIterableSpread","TypeError","_toConsumableArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","ownKeys","enumerableOnly","keys","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","push","apply","_objectSpread2","target","arguments","source","getOwnPropertyDescriptors","defineProperties","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeXYScalesForSeries","_series","xScaleSpec","yScaleSpec","series","map","serie","data","d","generateSeriesXY","stackX","stackY","xScale","computeScale","yScale","position","x","xStacked","y","yStacked","spec","generateSeriesAxis","scaleSpec","getValue","setValue","parseFloat","uniq","sortBy","uniqBy","sort","last","stackAxis","otherType","otherAxis","compare","isDate","stack","datum","find","stackValue","head","computeAxisSlices","id","computeXSlices","computeYSlices","scalePropType","shape"],"sources":["D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\linearScale.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\logScale.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\symlogScale.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\pointScale.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\defineProperty.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\timeHelpers.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\timeScale.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\bandScale.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\arrayLikeToArray.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\arrayWithoutHoles.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\iterableToArray.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\unsupportedIterableToArray.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\nonIterableSpread.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\toConsumableArray.js","D:\\Kltn\\test\\social-media\\node_modules\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime\\helpers\\esm\\objectSpread2.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\compute.js","D:\\Kltn\\test\\social-media\\node_modules\\@nivo\\scales\\src\\index.js"],"sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLinear } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const linearScale = (\n    { axis, min = 0, max = 'auto', stacked = false, reverse = false, clamp = false, nice = false },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = stacked === true ? values.minStacked : values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = stacked === true ? values.maxStacked : values.max\n    }\n\n    const scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0])\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'linear'\n    scale.stacked = stacked\n    scale.clamp(clamp)\n\n    return scale\n}\n\nexport const linearScalePropTypes = {\n    type: PropTypes.oneOf(['linear']).isRequired,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    stacked: PropTypes.bool,\n    reverse: PropTypes.bool,\n    clamp: PropTypes.bool,\n    nice: PropTypes.oneOfType([PropTypes.number, PropTypes.bool]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const logScale = ({ axis, base = 10, min = 'auto', max = 'auto' }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const hasZero = values.all.some(v => v === 0)\n    let sign\n    let hasMixedSign = false\n    values.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign === true) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasZero || hasMixedSign) {\n        throw new Error(\n            [\n                `a log scale domain must be strictly-positive or strictly-negative,`,\n                `and must not include or cross zero.`,\n            ].join('\\n')\n        )\n    }\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleLog()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    scale.type = 'log'\n\n    return scale\n}\n\nexport const logScalePropTypes = {\n    type: PropTypes.oneOf(['log']).isRequired,\n    base: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleSymlog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const symlogScale = (\n    { axis, constant = 1, min = 'auto', max = 'auto' },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleSymlog()\n        .domain([minValue, maxValue])\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    scale.type = 'symlog'\n\n    return scale\n}\n\nexport const symLogScalePropTypes = {\n    type: PropTypes.oneOf(['symlog']).isRequired,\n    constant: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scalePoint } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const pointScale = ({ axis }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const scale = scalePoint().range([0, size]).domain(values.all)\n\n    scale.type = 'point'\n\n    return scale\n}\n\nexport const pointScalePropTypes = {\n    type: PropTypes.oneOf(['point']).isRequired,\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { timeParse, utcParse } from 'd3-time-format'\n\nexport const TIME_PRECISION_MILLISECOND = 'millisecond'\nexport const TIME_PRECISION_SECOND = 'second'\nexport const TIME_PRECISION_MINUTE = 'minute'\nexport const TIME_PRECISION_HOUR = 'hour'\nexport const TIME_PRECISION_DAY = 'day'\nexport const TIME_PRECISION_MONTH = 'month'\nexport const TIME_PRECISION_YEAR = 'year'\n\nexport const timePrecisions = [\n    TIME_PRECISION_MILLISECOND,\n    TIME_PRECISION_SECOND,\n    TIME_PRECISION_MINUTE,\n    TIME_PRECISION_HOUR,\n    TIME_PRECISION_DAY,\n    TIME_PRECISION_MONTH,\n    TIME_PRECISION_YEAR,\n]\n\nexport const precisionCutOffs = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType = {\n    [TIME_PRECISION_MILLISECOND]: [],\n    [TIME_PRECISION_SECOND]: precisionCutOffs.slice(0, 1),\n    [TIME_PRECISION_MINUTE]: precisionCutOffs.slice(0, 2),\n    [TIME_PRECISION_HOUR]: precisionCutOffs.slice(0, 3),\n    [TIME_PRECISION_DAY]: precisionCutOffs.slice(0, 4),\n    [TIME_PRECISION_MONTH]: precisionCutOffs.slice(0, 5),\n    [TIME_PRECISION_YEAR]: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = precision => date => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n    if (format === 'native') return v => precisionFn(v)\n\n    const parseTime = useUTC ? utcParse(format) : timeParse(format)\n    return v => precisionFn(parseTime(v))\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleTime, scaleUtc } from 'd3-scale'\nimport PropTypes from 'prop-types'\nimport { createDateNormalizer, timePrecisions, TIME_PRECISION_MILLISECOND } from './timeHelpers'\n\nexport const timeScale = (\n    {\n        axis,\n        format = 'native',\n        precision = TIME_PRECISION_MILLISECOND,\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n    scale.domain([minValue, maxValue]).range([0, size])\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    scale.type = 'time'\n    scale.useUTC = useUTC\n\n    return scale\n}\n\nexport const timeScalePropTypes = {\n    type: PropTypes.oneOf(['time']).isRequired,\n    format: PropTypes.string,\n    precision: PropTypes.oneOf(timePrecisions),\n    nice: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.object]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\n\nexport const bandScalePropTypes = {\n    type: PropTypes.oneOf(['band']).isRequired,\n    round: PropTypes.bool,\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { linearScale } from './linearScale'\nimport { logScale } from './logScale'\nimport { symlogScale } from './symlogScale'\nimport { pointScale } from './pointScale'\nimport { timeScale } from './timeScale'\nimport { createDateNormalizer } from './timeHelpers'\n\nexport const getOtherAxis = axis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a, b) => a === b\nexport const compareDateValues = (a, b) => a.getTime() === b.getTime()\n\nexport const computeXYScalesForSeries = (_series, xScaleSpec, yScaleSpec, width, height) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    }))\n\n    let xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if (xScaleSpec.stacked === true) {\n        stackX(yScaleSpec.type, xy, series)\n    }\n    if (yScaleSpec.stacked === true) {\n        stackY(xScaleSpec.type, xy, series)\n    }\n\n    const xScale = computeScale({ ...xScaleSpec, axis: 'x' }, xy, width, height)\n    const yScale = computeScale({ ...yScaleSpec, axis: 'y' }, xy, width, height)\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x),\n                y:\n                    yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y),\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const computeScale = (spec, xy, width, height) => {\n    if (spec.type === 'linear') return linearScale(spec, xy, width, height)\n    else if (spec.type === 'point') return pointScale(spec, xy, width, height)\n    else if (spec.type === 'time') return timeScale(spec, xy, width, height)\n    else if (spec.type === 'log') return logScale(spec, xy, width, height)\n    else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height)\n}\n\nexport const generateSeriesXY = (series, xScaleSpec, yScaleSpec) => ({\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = (\n    series,\n    axis,\n    scaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)))\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        const parseTime = createDateNormalizer(scaleSpec)\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseTime(getValue(d)))\n            })\n        })\n    }\n\n    let all = []\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            all.push(getValue(d))\n        })\n    })\n\n    let min, max\n    if (scaleSpec.type === 'linear') {\n        all = uniq(all)\n        all = sortBy(all, v => v)\n        min = Math.min(...all)\n        max = Math.max(...all)\n    } else if (scaleSpec.type === 'time') {\n        all = uniqBy(all, v => v.getTime())\n        all = all\n            .slice(0)\n            .sort((a, b) => b - a)\n            .reverse()\n        min = all[0]\n        max = last(all)\n    } else {\n        all = uniq(all)\n        min = all[0]\n        max = last(all)\n    }\n\n    return { all, min, max }\n}\n\nexport const stackAxis = (axis, otherType, xy, series) => {\n    const otherAxis = getOtherAxis(axis)\n\n    let all = []\n    xy[otherAxis].all.forEach(v => {\n        const compare = isDate(v) ? compareDateValues : compareValues\n        const stack = []\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n            stack.push(stackValue)\n            all.push(stackValue)\n        })\n    })\n    all = all.filter(v => v !== null)\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nexport const stackX = (xy, otherType, series) => stackAxis('x', xy, otherType, series)\nexport const stackY = (xy, otherType, series) => stackAxis('y', xy, otherType, series)\n\nexport const computeAxisSlices = (axis, data) => {\n    const otherAxis = getOtherAxis(axis)\n\n    return data[otherAxis].all.map(v => {\n        const slice = {\n            id: v,\n            [otherAxis]: data[`${otherAxis}Scale`](v),\n            data: [],\n        }\n        const compare = isDate(v) ? compareDateValues : compareValues\n        data.series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            if (datum !== undefined) {\n                slice.data.push({\n                    ...datum,\n                    serie,\n                })\n            }\n        })\n        slice.data.reverse()\n\n        return slice\n    })\n}\n\nexport const computeXSlices = data => computeAxisSlices('x', data)\nexport const computeYSlices = data => computeAxisSlices('y', data)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { linearScalePropTypes } from './linearScale'\nimport { logScalePropTypes } from './logScale'\nimport { symLogScalePropTypes } from './symlogScale'\nimport { pointScalePropTypes } from './pointScale'\nimport { timeScalePropTypes } from './timeScale'\nimport { bandScalePropTypes } from './bandScale'\n\nexport * from './compute'\nexport * from './linearScale'\nexport * from './logScale'\nexport * from './symlogScale'\nexport * from './pointScale'\nexport * from './timeScale'\nexport * from './timeHelpers'\nexport * from './bandScale'\n\nexport const scalePropType = PropTypes.oneOfType([\n    PropTypes.shape(linearScalePropTypes),\n    PropTypes.shape(pointScalePropTypes),\n    PropTypes.shape(timeScalePropTypes),\n    PropTypes.shape(logScalePropTypes),\n    PropTypes.shape(symLogScalePropTypes),\n    PropTypes.shape(bandScalePropTypes),\n])\n"]},"metadata":{},"sourceType":"module"}