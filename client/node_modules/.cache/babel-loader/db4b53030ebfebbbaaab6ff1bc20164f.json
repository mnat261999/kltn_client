{"ast":null,"code":"import moment from \"moment\";\nexport const generateData = (formdata, formName) => {\n  let dataToSubmit = {};\n\n  for (let key in formdata) {\n    if (key !== \"confirmPassword\") {\n      if (key === \"dob\") {\n        if (formdata[key].valueAsNumber) {\n          dataToSubmit[key] = formdata[key].valueAsNumber;\n        } else {\n          dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\");\n        }\n      } else {\n        dataToSubmit[key] = formdata[key].value;\n      }\n    }\n  }\n\n  return dataToSubmit;\n};\nexport const ifFormValid = (formdata, formName) => {\n  let formValid = true;\n\n  for (let key in formdata) {\n    console.log(\"formdata[key].valid\", formdata[key].valid);\n    console.log(\"formValid\", formValid);\n    formValid = formdata[key].valid && formValid;\n  }\n\n  console.log(\"ress\", formValid);\n  return formValid;\n}; //Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\n\nexport const validate = (element, formdata = []) => {\n  let error = [true, \"\"];\n\n  if (element.validation.confirm) {\n    const valid = element.value.trim() === formdata[element.validation.confirm].value;\n    const message = `${valid ? \"\" : \"Password do not match\"}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex\n\n\n  if (element.validation.email) {\n    const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\n    const message = `${!valid ? \"Must be a valid email\" : \"\"}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không\n\n\n  if (element.validation.required) {\n    const valid = element.value.trim() !== \"\";\n    const message = `${!valid ? \"this field is required\" : \"\"}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  return error;\n};\nexport const update = (element, formdata, formName) => {\n  //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\n  //             Id(để xác định là field nào),\n  //             blur( luôn luôn bằng true)\n  //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị\n  const newFormdata = { ...formdata\n  }; //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào\n\n  const newElement = { ...newFormdata[element.id]\n  };\n  console.log(element.event); //Lấy value của field từ element.event.target.value\n\n  if (element.id === \"description\") {\n    console.log(element);\n\n    if (element.emojiInfo.emoji) {\n      newElement.value = newElement.value.toString().slice(0, element.emojiInfo.position) + element.event + newElement.value.toString().slice(element.emojiInfo.position);\n      console.log(newElement.value);\n    } else {\n      console.log(element.event);\n      newElement.value = element.event;\n    }\n  } else if (element.id === \"userTag\" || element.id === \"locationInput\") {\n    console.log(element.event);\n    newElement.value = element.event;\n  } else if (element.id === \"dob\") {\n    console.log(element.event.target.valueAsNumber);\n    newElement.value = element.event.target.value;\n    newElement.valueAsNumber = moment(element.event.target.valueAsNumber).format();\n  } else {\n    newElement.value = element.event.target.value;\n  }\n\n  if (element.blur) {\n    //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\n    let validData = validate(newElement, formdata); //Cập nhật lại valid và validationMessage trong newElement\n\n    newElement.valid = validData[0];\n    newElement.validationMessage = validData[1];\n  }\n\n  newElement.touched = element.blur; //Thêm newElement vào State newFormdata\n\n  newFormdata[element.id] = newElement;\n  console.log(newFormdata[element.id]);\n  return newFormdata;\n};\nexport const populateOptionFields = (formData, arrayData = [], field) => {\n  const newArray = [];\n  const newFormData = { ...formData\n  };\n\n  switch (field) {\n    case \"description\":\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    case \"userTag\":\n      arrayData.forEach(item => {\n        newArray.push(item.userName);\n      });\n      break;\n\n    case \"locationInput\":\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    default:\n      arrayData.forEach(item => {\n        newArray.push({\n          key: item._id,\n          value: item.name\n        });\n      });\n      break;\n  }\n\n  newFormData[field].config.options = newArray;\n  return newFormData;\n};\nexport const resetFields = (formData, formName) => {\n  const newFormData = { ...formData\n  };\n\n  for (let key in newFormData) {\n    if (key === \"images\") {\n      newFormData[key].value = [];\n    } else {\n      newFormData[key].value = \"\";\n    }\n\n    newFormData[key].valid = \"\";\n    newFormData[key].touched = \"\";\n    newFormData[key].validationMessage = \"\";\n  }\n\n  return newFormData;\n};\nconst hashtagOrWordRegex = /#*\\w.*/g; // Gets the word that the user's caret is positioned on.\n\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\n  // First, backtrack until we find a character that can't\n  // be part of a word or hashtag.\n  if (content !== undefined) {\n    let index = caretIndex - 1;\n    let character = content[index]; //console.log(content);\n\n    let res = \"\";\n\n    do {\n      //console.log(index,content[index]);\n      let matches = content[index].match(hashtagOrWordRegex); // if this character is not part of a hashtag (e.g.\n      // it's a space or a period), return the word or\n      // hashtag in front of it.\n      //console.log(index,matches)\n\n      if (!matches || !matches.length) {\n        res = content.slice(index + 1, content.length);\n        break;\n      } // Otherwise, go to the previous character\n\n\n      index -= 1;\n    } while (index > 0);\n\n    return res;\n  }\n};\n\nconst nonEditingKeys = [\"ArrowLeft\", \"ArrowRight\", \"Control\", \"Shift\"];\nexport const getActiveHashtag = (content, key, caretIndex) => {\n  if (nonEditingKeys.includes(key)) {\n    return null;\n  } // Figure out what word or hashtag the user is editing\n  // using the caret position and the content:\n\n\n  const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\n  console.log(activeWordOrHashtag); // if the word that the user is editing is a hashtag, return it.\n  // otherwise, return null.\n  //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\n};","map":{"version":3,"sources":["D:/Kltn/test/social-media/client/src/components/ultils/Form/FormActions.js"],"names":["moment","generateData","formdata","formName","dataToSubmit","key","valueAsNumber","value","format","ifFormValid","formValid","console","log","valid","validate","element","error","validation","confirm","trim","message","email","test","required","update","newFormdata","newElement","id","event","emojiInfo","emoji","toString","slice","position","target","blur","validData","validationMessage","touched","populateOptionFields","formData","arrayData","field","newArray","newFormData","forEach","item","push","name","userName","_id","config","options","resetFields","hashtagOrWordRegex","extractActiveWordOrHashtag","content","caretIndex","undefined","index","character","res","matches","match","length","nonEditingKeys","getActiveHashtag","includes","activeWordOrHashtag"],"mappings":"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","sourcesContent":["import moment from \"moment\";\n\nexport const generateData = (formdata, formName) => {\n  let dataToSubmit = {};\n  for (let key in formdata) {\n    if (key !== \"confirmPassword\") {\n      if (key === \"dob\") {\n        if (formdata[key].valueAsNumber) {\n          dataToSubmit[key] = formdata[key].valueAsNumber;\n        } else {\n          dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\");\n        }\n      } else {\n        dataToSubmit[key] = formdata[key].value;\n      }\n    }\n  }\n  return dataToSubmit;\n};\n\nexport const ifFormValid = (formdata, formName) => {\n  let formValid = true;\n\n  for (let key in formdata) {\n    console.log(\"formdata[key].valid\", formdata[key].valid);\n    console.log(\"formValid\", formValid);\n    formValid = formdata[key].valid && formValid;\n  }\n\n  console.log(\"ress\", formValid);\n  return formValid;\n};\n\n//Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\nexport const validate = (element, formdata = []) => {\n  let error = [true, \"\"];\n\n  if (element.validation.confirm) {\n    const valid =\n      element.value.trim() === formdata[element.validation.confirm].value;\n    const message = `${valid ? \"\" : \"Password do not match\"}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex\n  if (element.validation.email) {\n    const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\n    const message = `${!valid ? \"Must be a valid email\" : \"\"}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không\n  if (element.validation.required) {\n    const valid = element.value.trim() !== \"\";\n    const message = `${!valid ? \"this field is required\" : \"\"}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  return error;\n};\n\nexport const update = (element, formdata, formName) => {\n  //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\n  //             Id(để xác định là field nào),\n  //             blur( luôn luôn bằng true)\n\n  //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị\n  const newFormdata = { ...formdata };\n\n  //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào\n  const newElement = {\n    ...newFormdata[element.id],\n  };\n\n  console.log(element.event);\n  //Lấy value của field từ element.event.target.value\n  if (element.id === \"description\") {\n    console.log(element);\n    if (element.emojiInfo.emoji) {\n      newElement.value =\n        newElement.value.toString().slice(0, element.emojiInfo.position) +\n        element.event +\n        newElement.value.toString().slice(element.emojiInfo.position);\n      console.log(newElement.value);\n    } else {\n      console.log(element.event);\n      newElement.value = element.event;\n    }\n  } else if (element.id === \"userTag\" || element.id === \"locationInput\") {\n    console.log(element.event);\n    newElement.value = element.event;\n  } else if (element.id === \"dob\") {\n    console.log(element.event.target.valueAsNumber);\n    newElement.value = element.event.target.value;\n    newElement.valueAsNumber = moment(\n      element.event.target.valueAsNumber\n    ).format();\n  } else {\n    newElement.value = element.event.target.value;\n  }\n\n  if (element.blur) {\n    //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\n    let validData = validate(newElement, formdata);\n    //Cập nhật lại valid và validationMessage trong newElement\n    newElement.valid = validData[0];\n    newElement.validationMessage = validData[1];\n  }\n\n  newElement.touched = element.blur;\n  //Thêm newElement vào State newFormdata\n  newFormdata[element.id] = newElement;\n  console.log(newFormdata[element.id]);\n  return newFormdata;\n};\n\nexport const populateOptionFields = (formData, arrayData = [], field) => {\n  const newArray = [];\n  const newFormData = { ...formData };\n\n  switch (field) {\n    case \"description\":\n      arrayData.forEach((item) => {\n        newArray.push(item.name);\n      });\n      break;\n    case \"userTag\":\n      arrayData.forEach((item) => {\n        newArray.push(item.userName);\n      });\n      break;\n    case \"locationInput\":\n      arrayData.forEach((item) => {\n        newArray.push(item.name);\n      });\n      break;\n    default:\n      arrayData.forEach((item) => {\n        newArray.push({ key: item._id, value: item.name });\n      });\n      break;\n  }\n  newFormData[field].config.options = newArray;\n  return newFormData;\n};\n\nexport const resetFields = (formData, formName) => {\n  const newFormData = { ...formData };\n  for (let key in newFormData) {\n    if (key === \"images\") {\n      newFormData[key].value = [];\n    } else {\n      newFormData[key].value = \"\";\n    }\n    newFormData[key].valid = \"\";\n    newFormData[key].touched = \"\";\n    newFormData[key].validationMessage = \"\";\n  }\n  return newFormData;\n};\n\nconst hashtagOrWordRegex = /#*\\w.*/g;\n// Gets the word that the user's caret is positioned on.\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\n  // First, backtrack until we find a character that can't\n  // be part of a word or hashtag.\n  if (content !== undefined) {\n    let index = caretIndex - 1;\n    let character = content[index];\n    //console.log(content);\n    let res = \"\";\n    do {\n      //console.log(index,content[index]);\n      let matches = content[index].match(hashtagOrWordRegex);\n      // if this character is not part of a hashtag (e.g.\n      // it's a space or a period), return the word or\n      // hashtag in front of it.\n      //console.log(index,matches)\n      if (!matches || !matches.length) {\n        res = content.slice(index + 1, content.length);\n        break;\n      }\n      // Otherwise, go to the previous character\n      index -= 1;\n    } while (index > 0);\n    return res;\n  }\n};\n\nconst nonEditingKeys = [\"ArrowLeft\", \"ArrowRight\", \"Control\", \"Shift\"];\n\nexport const getActiveHashtag = (content, key, caretIndex) => {\n  if (nonEditingKeys.includes(key)) {\n    return null;\n  }\n\n  // Figure out what word or hashtag the user is editing\n  // using the caret position and the content:\n  const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\n  console.log(activeWordOrHashtag);\n  // if the word that the user is editing is a hashtag, return it.\n  // otherwise, return null.\n  //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\n};\n"]},"metadata":{},"sourceType":"module"}