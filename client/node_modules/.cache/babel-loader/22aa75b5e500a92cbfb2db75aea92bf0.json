{"ast":null,"code":"import moment from 'moment';\nexport const generateData = (formdata, formName) => {\n  let dataToSubmit = {};\n\n  for (let key in formdata) {\n    if (key !== 'confirmPassword') {\n      if (key === 'dob') {\n        if (formdata[key].valueAsNumber) {\n          dataToSubmit[key] = formdata[key].valueAsNumber;\n        } else {\n          dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\");\n        }\n      } else {\n        dataToSubmit[key] = formdata[key].value;\n      }\n    }\n  }\n\n  return dataToSubmit;\n};\nexport const ifFormValid = (formdata, formName) => {\n  let formValid = true;\n\n  for (let key in formdata) {\n    console.log(formdata[key].valid);\n    formValid = formdata[key].valid && formValid;\n  }\n\n  console.log(\"ress\", formValid);\n  return formValid;\n}; //Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\n\nexport const validate = (element, formdata = []) => {\n  let error = [true, ''];\n\n  if (element.validation.confirm) {\n    const valid = element.value.trim() === formdata[element.validation.confirm].value;\n    const message = `${valid ? '' : 'Password do not match'}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex     \n\n\n  if (element.validation.email) {\n    const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\n    const message = `${!valid ? 'Must be a valid email' : ''}`;\n    error = !valid ? [valid, message] : error;\n  } // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không  \n\n\n  if (element.validation.required) {\n    const valid = element.value.trim() !== '';\n    const message = `${!valid ? 'this field is required' : ''}`;\n    error = !valid ? [valid, message] : error;\n  }\n\n  return error;\n};\nexport const update = (element, formdata, formName) => {\n  //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\n  //             Id(để xác định là field nào),\n  //             blur( luôn luôn bằng true) \n  //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị \n  const newFormdata = { ...formdata\n  }; //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào \n\n  const newElement = { ...newFormdata[element.id]\n  };\n  console.log(element.event); //Lấy value của field từ element.event.target.value\n\n  if (element.id === \"description\") {\n    console.log(element);\n\n    if (element.emojiInfo.emoji) {\n      newElement.value = newElement.value.toString().slice(0, element.emojiInfo.position) + element.event + newElement.value.toString().slice(element.emojiInfo.position);\n      console.log(newElement.value);\n    } else {\n      console.log(element.event);\n      newElement.value = element.event;\n    }\n  } else if (element.id === \"userTag\" || element.id === \"locationInput\") {\n    console.log(element.event);\n    newElement.value = element.event;\n  } else if (element.id === \"dob\") {\n    console.log(element.event.target.valueAsNumber);\n    newElement.value = element.event.target.value;\n    newElement.valueAsNumber = moment(element.event.target.valueAsNumber).format();\n  } else {\n    newElement.value = element.event.target.value;\n  }\n\n  if (element.blur) {\n    //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\n    let validData = validate(newElement, formdata); //Cập nhật lại valid và validationMessage trong newElement\n\n    newElement.valid = validData[0];\n    newElement.validationMessage = validData[1];\n  }\n\n  newElement.touched = element.blur; //Thêm newElement vào State newFormdata\n\n  newFormdata[element.id] = newElement;\n  console.log(newFormdata[element.id]);\n  return newFormdata;\n};\nexport const populateOptionFields = (formData, arrayData = [], field) => {\n  const newArray = [];\n  const newFormData = { ...formData\n  };\n\n  switch (field) {\n    case 'description':\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    case 'userTag':\n      arrayData.forEach(item => {\n        newArray.push(item.userName);\n      });\n      break;\n\n    case 'locationInput':\n      arrayData.forEach(item => {\n        newArray.push(item.name);\n      });\n      break;\n\n    default:\n      arrayData.forEach(item => {\n        newArray.push({\n          key: item._id,\n          value: item.name\n        });\n      });\n      break;\n  }\n\n  newFormData[field].config.options = newArray;\n  return newFormData;\n};\nexport const resetFields = (formData, formName) => {\n  const newFormData = { ...formData\n  };\n\n  for (let key in newFormData) {\n    if (key === 'images') {\n      newFormData[key].value = [];\n    } else {\n      newFormData[key].value = '';\n    }\n\n    newFormData[key].valid = '';\n    newFormData[key].touched = '';\n    newFormData[key].validationMessage = '';\n  }\n\n  return newFormData;\n};\nconst hashtagOrWordRegex = /#*\\w.*/g; // Gets the word that the user's caret is positioned on.\n\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\n  // First, backtrack until we find a character that can't\n  // be part of a word or hashtag.\n  if (content !== undefined) {\n    let index = caretIndex - 1;\n    let character = content[index]; //console.log(content);\n\n    let res = '';\n\n    do {\n      //console.log(index,content[index]);\n      let matches = content[index].match(hashtagOrWordRegex); // if this character is not part of a hashtag (e.g.\n      // it's a space or a period), return the word or\n      // hashtag in front of it.\n      //console.log(index,matches)\n\n      if (!matches || !matches.length) {\n        res = content.slice(index + 1, content.length);\n        break;\n      } // Otherwise, go to the previous character\n\n\n      index -= 1;\n    } while (index > 0);\n\n    return res;\n  }\n};\n\nconst nonEditingKeys = ['ArrowLeft', 'ArrowRight', 'Control', 'Shift'];\nexport const getActiveHashtag = (content, key, caretIndex) => {\n  if (nonEditingKeys.includes(key)) {\n    return null;\n  } // Figure out what word or hashtag the user is editing\n  // using the caret position and the content:\n\n\n  const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\n  console.log(activeWordOrHashtag); // if the word that the user is editing is a hashtag, return it.\n  // otherwise, return null.\n  //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\n};","map":{"version":3,"sources":["D:/Kltn/test/social-media/client/src/components/ultils/Form/FormActions.js"],"names":["moment","generateData","formdata","formName","dataToSubmit","key","valueAsNumber","value","format","ifFormValid","formValid","console","log","valid","validate","element","error","validation","confirm","trim","message","email","test","required","update","newFormdata","newElement","id","event","emojiInfo","emoji","toString","slice","position","target","blur","validData","validationMessage","touched","populateOptionFields","formData","arrayData","field","newArray","newFormData","forEach","item","push","name","userName","_id","config","options","resetFields","hashtagOrWordRegex","extractActiveWordOrHashtag","content","caretIndex","undefined","index","character","res","matches","match","length","nonEditingKeys","getActiveHashtag","includes","activeWordOrHashtag"],"mappings":"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","sourcesContent":["import moment from 'moment';\r\n\r\nexport const generateData = (formdata, formName) =>{\r\n    \r\n    let dataToSubmit = {};\r\n    for (let key in formdata){\r\n        if(key !== 'confirmPassword')\r\n        {\r\n            if(key === 'dob'){\r\n                if(formdata[key].valueAsNumber){\r\n                dataToSubmit[key] = formdata[key].valueAsNumber; \r\n                }\r\n                else{\r\n                    dataToSubmit[key] = moment(formdata[key].value).format(\"YYYY-MM-DD\")\r\n                }\r\n            }else{\r\n                dataToSubmit[key] = formdata[key].value;\r\n            }\r\n        }\r\n    }\r\n    return dataToSubmit;\r\n}\r\n\r\nexport const ifFormValid = (formdata,formName) =>{\r\n    let formValid = true;\r\n\r\n    for (let key in formdata)\r\n    {\r\n        console.log(formdata[key].valid)\r\n        formValid = formdata[key].valid && formValid;\r\n    }\r\n\r\n    console.log(\"ress\", formValid)\r\n    return formValid;\r\n}\r\n\r\n//Nhận vào element và formdata(từ State của login truyền thông qua hàm update)\r\nexport const validate = (element,formdata=[]) =>{\r\n    \r\n    let error = [true,''];\r\n\r\n    if (element.validation.confirm) {\r\n        const valid = element.value.trim() === formdata[element.validation.confirm].value;\r\n        const message = `${ valid ?'':'Password do not match'}`;\r\n        error = !valid ? [valid, message] : error;\r\n    }\r\n\r\n    // Nếu giá trị email trong Validation = true thì kiểm tra value vs regex     \r\n    if (element.validation.email){\r\n        const valid = /(.+)@(.+){2,}\\.(.+){2,}/.test(element.value);\r\n        const message = `${!valid ? 'Must be a valid email' : ''}`;\r\n        error = !valid ? [valid, message] : error;\r\n    }\r\n\r\n    // Nếu giá trị required trong Validation = true thì kiểm tra value có rổng hay không  \r\n    if(element.validation.required){\r\n        const valid = element.value.trim() !== '';\r\n        const message = `${!valid ? 'this field is required' : ''}`;\r\n        error = !valid ? [valid,message] : error;\r\n    }\r\n\r\n    return error;\r\n}\r\n\r\nexport const update = (element, formdata, formName) =>{\r\n\r\n    //element gồm: event(event.target để lấy ra data ng dùng nhập trong field đi validate),\r\n    //             Id(để xác định là field nào),\r\n    //             blur( luôn luôn bằng true) \r\n\r\n    //copy formdata(formdata từ state của component login) ra một newFormData để cập nhật lại các giá trị \r\n    const newFormdata = {...formdata};\r\n\r\n    //Lấy ra formData của đối tượng có Id bằng với element.Id truyền vào \r\n    const newElement = {\r\n        ...newFormdata[element.id]\r\n    }\r\n    \r\n    console.log(element.event);\r\n    //Lấy value của field từ element.event.target.value\r\n    if (element.id === \"description\"){\r\n        console.log(element);\r\n        if(element.emojiInfo.emoji){\r\n            newElement.value = newElement.value.toString().slice(0, element.emojiInfo.position) \r\n                                + element.event\r\n                                + newElement.value.toString().slice(element.emojiInfo.position)                                \r\n            console.log(newElement.value)\r\n        }else{\r\n            console.log(element.event)\r\n            newElement.value = element.event;\r\n        }\r\n    }else if (element.id === \"userTag\" || element.id === \"locationInput\"){\r\n        console.log(element.event)\r\n        newElement.value = element.event;\r\n    }else if(element.id === \"dob\"){\r\n        console.log(element.event.target.valueAsNumber)\r\n        newElement.value = element.event.target.value;\r\n        newElement.valueAsNumber = moment(element.event.target.valueAsNumber).format()\r\n    }else{\r\n        newElement.value = element.event.target.value;\r\n    }\r\n  \r\n    if(element.blur){\r\n        //Kiểm tra value đc nhập vào field có hợp lệ không bằng hàm validate\r\n        let validData = validate(newElement,formdata);\r\n        //Cập nhật lại valid và validationMessage trong newElement\r\n        newElement.valid = validData[0];\r\n        newElement.validationMessage = validData[1];\r\n    }\r\n\r\n    newElement.touched = element.blur;\r\n    //Thêm newElement vào State newFormdata\r\n    newFormdata[element.id] = newElement;\r\n    console.log(newFormdata[element.id])\r\n    return newFormdata;\r\n};\r\n\r\nexport const populateOptionFields= (formData,arrayData = [], field) => {\r\n    const newArray = []\r\n    const newFormData = {...formData};\r\n\r\n    switch (field){\r\n        case ('description'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.name);\r\n            })\r\n            break;\r\n        case ('userTag'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.userName);\r\n            })\r\n            break;\r\n        case ('locationInput'):\r\n            arrayData.forEach(item => {\r\n                newArray.push(item.name);\r\n            })\r\n            break;\r\n        default:\r\n            arrayData.forEach(item => {\r\n                newArray.push({ key: item._id, value: item.name });\r\n            })\r\n            break;\r\n    }\r\n    newFormData[field].config.options = newArray;\r\n    return newFormData;\r\n}\r\n\r\nexport const resetFields = (formData,formName) => {\r\n    const newFormData = {...formData};\r\n    for(let key in newFormData){\r\n        if(key==='images'){\r\n            newFormData[key].value = [];\r\n        }else{\r\n            newFormData[key].value = '';\r\n        }\r\n        newFormData[key].valid = '';\r\n        newFormData[key].touched = '';\r\n        newFormData[key].validationMessage = '';\r\n    }    \r\n    return newFormData;\r\n}\r\n\r\nconst hashtagOrWordRegex = /#*\\w.*/g;\r\n// Gets the word that the user's caret is positioned on.\r\nconst extractActiveWordOrHashtag = (content, caretIndex) => {\r\n    // First, backtrack until we find a character that can't\r\n    // be part of a word or hashtag.\r\n    if(content !== undefined){\r\n    let index = caretIndex-1;\r\n    let character = content[index];\r\n    //console.log(content);\r\n    let res = '';\r\n    do {\r\n        //console.log(index,content[index]);\r\n        let matches = content[index].match(hashtagOrWordRegex);\r\n        // if this character is not part of a hashtag (e.g.\r\n        // it's a space or a period), return the word or\r\n        // hashtag in front of it.\r\n        //console.log(index,matches)\r\n        if (!matches || !matches.length) {\r\n            res = content.slice(index+1, content.length)\r\n            break;\r\n        }\r\n        // Otherwise, go to the previous character\r\n        index -= 1\r\n    } while (index > 0)\r\n    return res;\r\n    }\r\n}\r\n\r\nconst nonEditingKeys = [\r\n    'ArrowLeft',\r\n    'ArrowRight',\r\n    'Control',\r\n    'Shift',\r\n];\r\n\r\nexport const getActiveHashtag = (content, key, caretIndex) => {\r\n\r\n    if (nonEditingKeys.includes(key)) {\r\n        return null;\r\n    }\r\n\r\n    // Figure out what word or hashtag the user is editing\r\n    // using the caret position and the content:\r\n    const activeWordOrHashtag = extractActiveWordOrHashtag(content, caretIndex);\r\n    console.log(activeWordOrHashtag);\r\n    // if the word that the user is editing is a hashtag, return it.\r\n    // otherwise, return null.\r\n    //return activeWordOrHashtag[0] === '#' ? activeWordOrHashtag : null;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}