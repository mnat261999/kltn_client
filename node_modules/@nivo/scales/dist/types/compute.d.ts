import { ScaleAxis, ScaleSpec, Series, ScaleValue, SerieAxis, ComputedSerieAxis } from './types';
declare type XY = ReturnType<typeof generateSeriesXY>;
declare type StackedXY = {
    [K in keyof XY]: XY[K] & {
        maxStacked: number;
        minStacked: number;
    };
};
declare type InputXYSeries = Record<'x' | 'y', number | string | Date | null>;
interface Data {
    x: number;
    xStacked: number | null;
    y: number;
    yStacked: number | null;
    [key: string]: number | null;
}
declare type XYSeries = InputXYSeries & {
    data: Data[];
};
interface ComputedXYSeries extends InputXYSeries {
    data: Array<{
        data: Data;
        position: {
            x: ScaleValue | null;
            y: ScaleValue | null;
        };
    }>;
}
export declare const getOtherAxis: (axis: ScaleAxis) => ScaleAxis;
export declare const compareValues: (a: string | number, b: string | number) => boolean;
export declare const compareDateValues: (a: Date, b: Date) => boolean;
export declare function computeScale<Input extends ScaleValue>(spec: ScaleSpec, data: ComputedSerieAxis<any>, size: number, axis: ScaleAxis): import("./types").ScaleSymLog | import("d3-scale").ScaleLogarithmic<number, number, never> | import("./types").ScaleLinear<number> | import("./types").ScalePoint<Input> | import("./types").ScaleBand<Input> | import("./types").ScaleTime<number | Date | {
    valueOf(): number;
}>;
export declare const computeXYScalesForSeries: (_series: XYSeries[], xScaleSpec: ScaleSpec, yScaleSpec: ScaleSpec, width: number, height: number) => {
    series: ComputedXYSeries[];
    xScale: import("./types").ScaleSymLog | import("d3-scale").ScaleLogarithmic<number, number, never> | import("./types").ScaleLinear<number> | import("./types").ScaleTime<number | Date | {
        valueOf(): number;
    }> | import("./types").ScalePoint<ScaleValue> | import("./types").ScaleBand<ScaleValue>;
    yScale: import("./types").ScaleSymLog | import("d3-scale").ScaleLogarithmic<number, number, never> | import("./types").ScaleLinear<number> | import("./types").ScaleTime<number | Date | {
        valueOf(): number;
    }> | import("./types").ScalePoint<ScaleValue> | import("./types").ScaleBand<ScaleValue>;
    x: {
        all: unknown[];
        min: unknown;
        max: unknown;
    };
    y: {
        all: unknown[];
        min: unknown;
        max: unknown;
    };
};
export declare const generateSeriesXY: <XValue extends ScaleValue, YValue extends ScaleValue>(series: Series<XValue, YValue>, xScaleSpec: ScaleSpec, yScaleSpec: ScaleSpec) => {
    x: {
        all: unknown[];
        min: unknown;
        max: unknown;
    };
    y: {
        all: unknown[];
        min: unknown;
        max: unknown;
    };
};
/**
 * Normalize data according to scale type, (time => Date, linear => Number)
 * compute sorted unique values and min/max.
 */
export declare const generateSeriesAxis: <Axis extends ScaleAxis, Value extends ScaleValue>(series: SerieAxis<Axis, Value>, axis: Axis, scaleSpec: ScaleSpec, { getValue, setValue, }?: {
    getValue?: ((d: {
        data: Record<Axis, Value | null>;
    }) => Value | null) | undefined;
    setValue?: ((d: {
        data: Record<Axis, Value | null>;
    }, v: Value) => void) | undefined;
}) => {
    all: unknown[];
    min: unknown;
    max: unknown;
};
export declare const stackAxis: (axis: ScaleAxis, xy: StackedXY, series: ComputedXYSeries[]) => void;
export {};
//# sourceMappingURL=compute.d.ts.map